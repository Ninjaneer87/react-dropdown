{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dropdown",
  "type": "registry:ui",
  "title": "Dropdown",
  "description": "A fully-featured dropdown component with nested menus, sections, and keyboard navigation.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://raw.githubusercontent.com/Ninjaneer87/react-dropdown/main/packages/lab/registry/popover.json"
  ],
  "files": [
    {
      "path": "components/ui/dropdown/Dropdown.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/Dropdown.tsx",
      "content": "import React, { ReactNode, useState } from 'react';\nimport { DropdownContext } from '../../context/DropdownContext';\nimport DropdownMenu from './DropdownMenu';\nimport DropdownHeader from './DropdownHeader';\nimport DropdownFooter from './DropdownFooter';\nimport DropdownSection from './DropdownSection';\nimport DropdownItem from './DropdownItem';\nimport DropdownTrigger from './DropdownTrigger';\nimport DropdownDivider from './DropdownDivider';\nimport { DropdownComposition, DropdownProps } from '../../types';\nimport Popover from '../Popover/Popover';\nimport { defaultChildCaret, defaultRootCaret } from '../../utils/elements';\nimport { Slot } from '@/components/utility/Slot';\n\nconst Dropdown = ({\n  caret,\n  children,\n  trigger,\n  shouldFlip = true,\n  shouldBlockScroll = true,\n  shouldCloseOnScroll = !shouldBlockScroll,\n  shouldCloseOnBlur = true,\n  shouldCloseOnEsc = true,\n  shouldCloseOnSelection = true,\n  backdrop,\n  isDisabled,\n  isOpen: controlledIsOpen,\n  onOpen,\n  onClose,\n  onBlur,\n  onOpenChange,\n  isNested = false,\n  fullWidth = isNested,\n  placement = isNested ? 'right-start' : 'bottom-center',\n  showCaret = isNested,\n  openOnHover = isNested,\n  growContent,\n  offset,\n  autoFocus = 'menu',\n  focusTrapProps = {\n    autoFocus: autoFocus === 'none',\n    trapFocus: true,\n  },\n  classNames,\n}: DropdownProps & DropdownComposition) => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const open = controlledIsOpen ?? isOpen;\n\n  let dropdownTrigger: ReactNode | null = trigger ?? null;\n  let dropdownMenu: ReactNode | null = null;\n\n  // Validate children\n  React.Children.forEach(children, (child) => {\n    if (!React.isValidElement(child)) return;\n\n    switch (child.type) {\n      case DropdownTrigger: {\n        if (dropdownTrigger) {\n          throw new Error(\n            'Dropdown component can have only one DropdownTrigger or a \"trigger\" prop, not both',\n          );\n        }\n\n        dropdownTrigger = child;\n        break;\n      }\n\n      case DropdownMenu: {\n        if (dropdownMenu) {\n          throw new Error('Dropdown component can have only one DropdownMenu');\n        }\n\n        dropdownMenu = child;\n        break;\n      }\n\n      default: {\n        throw new Error(\n          `Dropdown component only accepts DropdownTrigger and DropdownMenu components as children`,\n        );\n      }\n    }\n  });\n\n  if (!dropdownTrigger) {\n    throw new Error(\n      'Dropdown component requires a DropdownTrigger or a \"trigger\" prop',\n    );\n  }\n\n  if (!dropdownMenu) {\n    throw new Error('Dropdown component requires a DropdownMenu');\n  }\n\n  const triggerCaretContent = showCaret\n    ? caret ?? (isNested ? defaultChildCaret : defaultRootCaret)\n    : null;\n\n  const dropdownJSX = (\n    <Popover\n      openOnHover={openOnHover}\n      isNested={isNested}\n      delayHide={isNested || openOnHover ? 300 : 0}\n      delayShow={isNested || openOnHover ? 100 : 0}\n      fullWidth={fullWidth}\n      shouldFlip={shouldFlip}\n      shouldBlockScroll={shouldBlockScroll}\n      shouldCloseOnScroll={shouldCloseOnScroll}\n      shouldCloseOnBlur={shouldCloseOnBlur}\n      shouldCloseOnEsc={shouldCloseOnEsc}\n      backdrop={backdrop}\n      focusTriggerOnClose\n      placement={placement}\n      isDisabled={isDisabled}\n      isOpen={open}\n      growContent={growContent}\n      offset={offset}\n      classNames={classNames?.popover}\n      focusTrapProps={focusTrapProps}\n      onOpen={() => {\n        setIsOpen(true);\n        if (onOpen) onOpen();\n      }}\n      onClose={() => {\n        setIsOpen(false);\n        if (onClose) onClose();\n      }}\n      onBlur={() => {\n        if (onBlur) onBlur();\n      }}\n      onOpenChange={(isOpen) => {\n        setIsOpen(isOpen);\n        if (onOpenChange) onOpenChange(isOpen);\n      }}\n    >\n      <Popover.Trigger>\n        {isNested ? (\n          <Slot\n            shouldCloseOnSelection={false}\n            isHighlighted={isOpen}\n            endContent={triggerCaretContent}\n            disabled={isDisabled}\n          >\n            {dropdownTrigger}\n          </Slot>\n        ) : (\n          dropdownTrigger\n        )}\n      </Popover.Trigger>\n\n      <Popover.Content>{dropdownMenu}</Popover.Content>\n    </Popover>\n  );\n\n  return (\n    <DropdownContext.Provider\n      value={{ shouldCloseOnSelection, autoFocus, classNames }}\n    >\n      {dropdownJSX}\n    </DropdownContext.Provider>\n  );\n};\n\nDropdown.Menu = DropdownMenu;\nDropdown.Header = DropdownHeader;\nDropdown.Footer = DropdownFooter;\nDropdown.Section = DropdownSection;\nDropdown.Item = DropdownItem;\nDropdown.Trigger = DropdownTrigger;\nDropdown.Divider = DropdownDivider;\n\nexport default Dropdown;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownMenu.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownMenu.tsx",
      "content": "import { useDropdownContext } from '../../context/DropdownContext';\nimport { DropdownMenuContext } from '../../context/DropdownMenuContext';\nimport { usePopoverContext } from '../../context/PopoverContext';\nimport { DropdownMenuProps } from '../../types';\nimport { useKeyboardNavigation } from '../../hooks/useKeyboardNavigation';\nimport { cn } from '../../utils/common';\n\nfunction DropdownMenu({ children, classNames }: DropdownMenuProps) {\n  const dropdownContext = useDropdownContext();\n  const popoverContext = usePopoverContext();\n\n  if (!dropdownContext) {\n    throw new Error('DropdownMenu should be used within a Dropdown component');\n  }\n\n  if (!popoverContext) {\n    throw new Error('DropdownMenu should be used within a Popover component');\n  }\n\n  const { autoFocus, classNames: contextClassNames } = dropdownContext;\n  const { isOpen } = popoverContext;\n  const { containerRef, onKeyDown, mutationContainerRef } =\n    useKeyboardNavigation<HTMLDivElement>({\n      isActive: isOpen,\n      autoFocus,\n    });\n\n  const baseClassName =\n    'rounded-lg w-full min-w-[200px] relative outline-none! border-none!';\n\n  return (\n    <DropdownMenuContext.Provider value={{}}>\n      <div\n        className={cn(\n          baseClassName,\n          contextClassNames?.menu?.base,\n          classNames?.base,\n        )}\n        onKeyDown={onKeyDown}\n        ref={(node) => {\n          containerRef.current = node;\n          mutationContainerRef.current = node;\n        }}\n        tabIndex={0}\n      >\n        {children}\n      </div>\n    </DropdownMenuContext.Provider>\n  );\n}\n\nexport default DropdownMenu;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownItem.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownItem.tsx",
      "content": "import { ElementType } from 'react';\nimport { useDropdownContext } from '../../context/DropdownContext';\nimport { useDropdownMenuContext } from '../../context/DropdownMenuContext';\nimport { DropdownItemProps } from '../../types';\nimport { usePopoverRootContext } from '../../context/PopoverRootContext';\nimport { cn } from '../../utils/common';\n\nfunction DropdownItem<T extends ElementType = 'div'>(\n  props: DropdownItemProps<T>,\n) {\n  const {\n    children,\n    onClick,\n    isHighlighted,\n    ref,\n    as: Component = 'div',\n    shouldCloseOnSelection,\n    disabled,\n    showDisabledStyles = disabled,\n    startContent,\n    endContent,\n    classNames,\n    description,\n    ...rest\n  } = props;\n  const dropdownContext = useDropdownContext();\n  const dropdownMenuContext = useDropdownMenuContext();\n  const popoverRootContext = usePopoverRootContext();\n\n  if (!dropdownContext) {\n    throw new Error('DropdownItem should be used within a Dropdown component');\n  }\n\n  if (!dropdownMenuContext) {\n    throw new Error(\n      'DropdownItem should be used within a DropdownMenu component',\n    );\n  }\n\n  if (!popoverRootContext) {\n    throw new Error('DropdownItem should be used within a Popover component');\n  }\n\n  const { classNames: contextClassNames } = dropdownContext;\n\n  const { handleCloseRoot } = popoverRootContext;\n\n  const closeOnSelection =\n    shouldCloseOnSelection ?? dropdownContext.shouldCloseOnSelection;\n\n  function handleClick() {\n    if (disabled) return;\n\n    if (onClick) {\n      onClick();\n    }\n\n    if (closeOnSelection) {\n      handleCloseRoot();\n    }\n  }\n\n  function onKeyDown(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (disabled) return;\n\n    if (event.key === 'Enter' || event.key === ' ') {\n      if (event.key === ' ') event.preventDefault();\n\n      if (onClick) {\n        event.stopPropagation();\n        handleClick();\n\n        return;\n      }\n\n      // Trigger native click to support Link components and other clickable elements\n      event.stopPropagation();\n      (event.currentTarget as HTMLElement).click();\n\n      if (closeOnSelection) {\n        handleCloseRoot();\n      }\n    }\n  }\n\n  const baseClassName = cn(\n    'p-2 focus-visible:bg-gray-200 focus-within:bg-gray-200 rounded-lg transition-all w-full flex cursor-pointer items-center gap-2',\n    disabled && showDisabledStyles ? 'opacity-60 pointer-events-none' : '',\n    isHighlighted ? 'bg-gray-300' : '',\n  );\n  const startContentClassName = cn('shrink-0 inline-flex');\n  const mainContentClassName = cn('shrink-0 grow inline-block');\n  const textContentClassName = cn('');\n  const descriptionContentClassName = cn('text-xs opacity-60');\n  const endContentClassName = cn('ml-auto shrink-0 inline-flex');\n\n  return (\n    <Component\n      {...rest}\n      ref={ref}\n      data-focusable-item\n      data-highlighted-item={isHighlighted}\n      tabIndex={disabled ? -1 : 0}\n      data-disabled={disabled}\n      aria-disabled={disabled}\n      disabled={disabled}\n      onClick={handleClick}\n      onKeyDown={onKeyDown}\n      className={cn(\n        baseClassName,\n        contextClassNames?.item?.base,\n        classNames?.base,\n      )}\n    >\n      {startContent && (\n        <span\n          className={cn(\n            startContentClassName,\n            contextClassNames?.item?.startContent,\n            classNames?.startContent,\n          )}\n        >\n          {startContent}\n        </span>\n      )}\n\n      <span\n        className={cn(\n          mainContentClassName,\n          contextClassNames?.item?.mainContent,\n          classNames?.mainContent,\n        )}\n      >\n        <div\n          className={cn(\n            textContentClassName,\n            contextClassNames?.item?.textContent,\n            classNames?.textContent,\n          )}\n        >\n          {children}\n        </div>\n\n        {description && (\n          <div\n            className={cn(\n              descriptionContentClassName,\n              contextClassNames?.item?.descriptionContent,\n              classNames?.descriptionContent,\n            )}\n          >\n            {description}\n          </div>\n        )}\n      </span>\n\n      {endContent && (\n        <span\n          className={cn(\n            endContentClassName,\n            contextClassNames?.item?.endContent,\n            classNames?.endContent,\n          )}\n        >\n          {endContent}\n        </span>\n      )}\n    </Component>\n  );\n}\n\nexport default DropdownItem;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownTrigger.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownTrigger.tsx",
      "content": "import { useDropdownContext } from '../../context/DropdownContext';\nimport { DropdownTriggerProps } from '../../types';\nimport { Slot } from '@/components/utility/Slot';\n\nfunction DropdownTrigger({\n  children,\n  ...rest\n}: DropdownTriggerProps & Record<string, unknown>) {\n  const dropdownContext = useDropdownContext();\n\n  if (!dropdownContext) {\n    throw new Error(\n      'DropdownTrigger should be used within a Dropdown component',\n    );\n  }\n\n  return <Slot {...rest}>{children}</Slot>;\n}\n\nexport default DropdownTrigger;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownHeader.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownHeader.tsx",
      "content": "import { useDropdownContext } from '../../context/DropdownContext';\nimport { useDropdownMenuContext } from '../../context/DropdownMenuContext';\nimport { DropdownHeaderProps } from '../../types';\nimport { cn } from '../../utils/common';\n\nfunction DropdownHeader({\n  children,\n  isSticky,\n  classNames,\n}: DropdownHeaderProps) {\n  const dropdownContext = useDropdownContext();\n  const dropdownMenuContext = useDropdownMenuContext();\n\n  if (!dropdownContext) {\n    throw new Error(\n      'DropdownHeader should be used within a Dropdown component',\n    );\n  }\n\n  if (!dropdownMenuContext) {\n    throw new Error(\n      'DropdownHeader should be used within a DropdownMenu component',\n    );\n  }\n\n  const { classNames: contextClassNames } = dropdownContext;\n\n  const baseClassName = cn(\n    'p-2',\n    isSticky ? 'sticky top-0 z-10 bg-inherit shadow-sm' : '',\n  );\n\n  return (\n    <header\n      className={cn(\n        baseClassName,\n        contextClassNames?.header?.base,\n        classNames?.base,\n      )}\n    >\n      {children}\n    </header>\n  );\n}\n\nexport default DropdownHeader;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownFooter.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownFooter.tsx",
      "content": "import { useDropdownContext } from '../../context/DropdownContext';\nimport { useDropdownMenuContext } from '../../context/DropdownMenuContext';\nimport { DropdownFooterProps } from '../../types';\nimport { cn } from '../../utils/common';\n\nfunction DropdownFooter({\n  children,\n  isSticky,\n  classNames,\n}: DropdownFooterProps) {\n  const dropdownContext = useDropdownContext();\n  const dropdownMenuContext = useDropdownMenuContext();\n\n  if (!dropdownContext) {\n    throw new Error(\n      'DropdownFooter should be used within a Dropdown component',\n    );\n  }\n\n  if (!dropdownMenuContext) {\n    throw new Error(\n      'DropdownFooter should be used within a DropdownMenu component',\n    );\n  }\n\n  const { classNames: contextClassNames } = dropdownContext;\n\n  const baseClassNames = cn(\n    'p-2',\n    isSticky ? 'sticky bottom-0 z-10 bg-inherit shadow-sm' : '',\n  );\n\n  return (\n    <footer\n      className={cn(\n        baseClassNames,\n        contextClassNames?.footer?.base,\n        classNames?.base,\n      )}\n    >\n      {children}\n    </footer>\n  );\n}\n\nexport default DropdownFooter;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownSection.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownSection.tsx",
      "content": "import { useDropdownContext } from '../../context/DropdownContext';\nimport { useDropdownMenuContext } from '../../context/DropdownMenuContext';\nimport { usePopoverContext } from '../../context/PopoverContext';\nimport { useInfiniteScroll } from '../../hooks/useInfiniteScroll';\nimport { DropdownSectionProps } from '../../types';\nimport { cn } from '../../utils/common';\n\nfunction DropdownSection({\n  children,\n  scrolling,\n  title,\n  isStickyTitle = true,\n  infiniteScrollProps,\n  classNames,\n}: DropdownSectionProps) {\n  const dropdownContext = useDropdownContext();\n  const popoverContext = usePopoverContext();\n  const dropdownMenuContext = useDropdownMenuContext();\n\n  if (!dropdownContext) {\n    throw new Error(\n      'DropdownSection should be used within a Dropdown component',\n    );\n  }\n  if (!popoverContext) {\n    throw new Error(\n      'DropdownSection should be used within a Popover component',\n    );\n  }\n\n  if (!dropdownMenuContext) {\n    throw new Error(\n      'DropdownSection should be used within a DropdownMenu component',\n    );\n  }\n\n  const { classNames: contextClassNames } = dropdownContext;\n\n  const { isOpen } = popoverContext;\n\n  const [loaderRef, scrollerRef] = useInfiniteScroll<never, HTMLDivElement>({\n    hasMore: infiniteScrollProps?.hasMore,\n    isEnabled: isOpen && !!infiniteScrollProps,\n    onLoadMore: () => infiniteScrollProps?.onLoadMore(),\n  });\n\n  const baseClassName = cn(\n    'bg-inherit',\n    scrolling ? 'max-h-[250px] overflow-y-auto scroll-pt-12' : '',\n  );\n\n  const titleClassName = cn(\n    'bg-gray-100 p-1 mb-2 text-sm font-semibold text-gray-400',\n    isStickyTitle ? 'sticky top-0 z-10 rounded-sm' : '',\n  );\n\n  return (\n    <div\n      className={cn(\n        baseClassName,\n        contextClassNames?.section?.base,\n        classNames?.base,\n      )}\n      ref={scrollerRef}\n    >\n      {title && (\n        <div\n          className={cn(\n            titleClassName,\n            contextClassNames?.section?.title,\n            classNames?.title,\n          )}\n        >\n          {title}\n        </div>\n      )}\n      {children}\n      {infiniteScrollProps?.hasMore && <div ref={loaderRef} />}\n    </div>\n  );\n}\n\nexport default DropdownSection;\n"
    },
    {
      "path": "components/ui/dropdown/DropdownDivider.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/DropdownDivider.tsx",
      "content": "import { useDropdownContext } from '../../context/DropdownContext';\nimport { useDropdownMenuContext } from '../../context/DropdownMenuContext';\nimport { DropdownDividerProps } from '../../types';\nimport { cn } from '../../utils/common';\nimport { dividerBaseClassName } from '../../utils/elements';\n\nfunction DropdownDivider({ classNames }: DropdownDividerProps) {\n  const dropdownContext = useDropdownContext();\n  const dropdownMenuContext = useDropdownMenuContext();\n\n  if (!dropdownContext) {\n    throw new Error(\n      'DropdownDivider should be used within a Dropdown component',\n    );\n  }\n\n  if (!dropdownMenuContext) {\n    throw new Error(\n      'DropdownDivider should be used within a DropdownMenu component',\n    );\n  }\n\n  const { classNames: contextClassNames } = dropdownContext;\n\n  return (\n    <div\n      className={cn(\n        dividerBaseClassName,\n        contextClassNames?.divider?.base,\n        classNames?.base,\n      )}\n    />\n  );\n}\n\nexport default DropdownDivider;\n"
    },
    {
      "path": "components/ui/dropdown/index.ts",
      "type": "registry:ui",
      "target": "components/ui/dropdown/index.ts",
      "content": "export { default as Dropdown } from './Dropdown';\nexport { default as DropdownDivider } from './DropdownDivider';\nexport { default as DropdownFooter } from './DropdownFooter';\nexport { default as DropdownHeader } from './DropdownHeader';\nexport { default as DropdownItem } from './DropdownItem';\nexport { default as DropdownMenu } from './DropdownMenu';\nexport { default as DropdownSection } from './DropdownSection';\nexport { default as DropdownTrigger } from './DropdownTrigger';\n"
    },
    {
      "path": "components/ui/dropdown/context/DropdownContext.ts",
      "type": "registry:ui",
      "target": "components/ui/dropdown/context/DropdownContext.ts",
      "content": "import { createContext, useContext } from 'react';\nimport { DropdownClassNames, ListAutoFocus } from '../types';\n\ntype DropdownContextType = {\n  shouldCloseOnSelection?: boolean;\n  autoFocus?: ListAutoFocus;\n  classNames?: DropdownClassNames;\n};\n\nexport const DropdownContext = createContext<DropdownContextType | null>(null);\n\nexport const useDropdownContext = () => useContext(DropdownContext);\n"
    },
    {
      "path": "components/ui/dropdown/context/DropdownMenuContext.ts",
      "type": "registry:ui",
      "target": "components/ui/dropdown/context/DropdownMenuContext.ts",
      "content": "import { createContext, useContext } from 'react';\n\ntype DropdownMenuContextType = Record<PropertyKey, unknown>;\n\nexport const DropdownMenuContext =\n  createContext<DropdownMenuContextType | null>(null);\n\nexport const useDropdownMenuContext = () => useContext(DropdownMenuContext);\n"
    },
    {
      "path": "components/ui/dropdown/utility/Slot.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/utility/Slot.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as React from 'react';\nimport { composeRefs } from '../../../utils/compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ntype SlotProps = React.HTMLAttributes<HTMLElement> & {\n  children?: React.ReactNode;\n} & Record<string, unknown>;\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>(\n    (props, forwardedRef) => {\n      const { children, ...slotProps } = props;\n      const childrenArray = React.Children.toArray(children as React.ReactNode);\n      const slottable = childrenArray.find(isSlottable);\n\n      if (slottable) {\n        // the new element to render is the one passed as a child of `Slottable`\n        const newElement = slottable.props.children;\n\n        const newChildren = childrenArray.map((child) => {\n          if (child === slottable) {\n            // because the new element will be the one rendered, we are only interested\n            // in grabbing its children (`newElement.props.children`)\n            if (React.Children.count(newElement) > 1)\n              return React.Children.only(null);\n            return React.isValidElement(newElement)\n              ? (newElement.props as { children: React.ReactNode }).children\n              : null;\n          } else {\n            return child;\n          }\n        });\n\n        return (\n          <SlotClone {...slotProps} ref={forwardedRef}>\n            {React.isValidElement(newElement)\n              ? React.cloneElement(newElement, undefined, newChildren)\n              : null}\n          </SlotClone>\n        );\n      }\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {children as React.ReactNode}\n        </SlotClone>\n      );\n    },\n  );\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>(\n    (props, forwardedRef) => {\n      const { children, ...slotProps } = props;\n\n      if (React.isValidElement(children)) {\n        const childrenRef = getElementRef(children);\n        const props = mergeProps(slotProps, children.props as AnyProps);\n        // do not pass ref to React.Fragment for React 19 compatibility\n        if (children.type !== React.Fragment) {\n          props.ref = forwardedRef\n            ? composeRefs(forwardedRef, childrenRef)\n            : childrenRef;\n        }\n        return React.cloneElement(children, props);\n      }\n\n      return React.Children.count(children) > 1\n        ? React.Children.only(null)\n        : null;\n    },\n  );\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('slottable-identifier');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __slottableId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__slottableId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode,\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__slottableId' in child.type &&\n    child.type.__slottableId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue]\n        .filter(Boolean)\n        .join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (\n    (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref\n  );\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n"
    },
    {
      "path": "components/ui/dropdown/utils/elements.tsx",
      "type": "registry:ui",
      "target": "components/ui/dropdown/utils/elements.tsx",
      "content": "export const defaultRootCaret = (\n  <span className=\"shrink-0 scale-x-[2]\">&#9662;</span>\n);\nexport const defaultChildCaret = (\n  <span className=\"shrink-0 scale-x-[1] scale-y-[1.4]\">&#9656;</span>\n);\n\nexport const dividerBaseClassName = 'h-px bg-gray-200 w-full my-2';\n"
    },
    {
      "path": "components/ui/dropdown/utils/common.ts",
      "type": "registry:ui",
      "target": "components/ui/dropdown/utils/common.ts",
      "content": "import { CSSProperties } from 'react';\nimport { PopoverAlign, PopoverPlacement, PopoverPosition } from '../types';\nimport { type ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(...inputs));\n}\n\nexport type Coords = {\n  top?: CSSProperties['width'];\n  left?: CSSProperties['width'];\n  bottom?: CSSProperties['width'];\n  right?: CSSProperties['width'];\n};\n\nexport function growContentPosition(\n  placement: PopoverPlacement,\n  offset: number,\n  triggerRect: DOMRect,\n): Coords {\n  const [position] = placement.split('-') as [PopoverPosition, PopoverAlign];\n\n  let top, left, bottom, right: CSSProperties['width'];\n\n  //! Position\n  // Top\n  if (position === 'top') {\n    bottom = window.innerHeight - triggerRect.top + offset;\n    left = 0;\n    right = 0;\n  }\n  // Bottom\n  if (position === 'bottom') {\n    top = triggerRect.bottom + offset;\n    left = 0;\n    right = 0;\n  }\n  // Left\n  if (position === 'left') {\n    right = window.innerWidth - triggerRect.left + offset;\n    top = 0;\n    bottom = 0;\n    left = 0;\n  }\n  // Right\n  if (position === 'right') {\n    left = triggerRect.right + offset;\n    top = 0;\n    bottom = 0;\n    right = 0;\n  }\n\n  return {\n    ...(top !== undefined && { top }),\n    ...(left !== undefined && { left }),\n    ...(bottom !== undefined && { bottom }),\n    ...(right !== undefined && { right }),\n  };\n}\n\nexport function createPositionFromPlacement(\n  placement: PopoverPlacement,\n  offset: number,\n  triggerRect: DOMRect,\n  popoverElement: HTMLDivElement | undefined,\n): Coords {\n  const [position, align] = placement.split('-') as [\n    PopoverPosition,\n    PopoverAlign,\n  ];\n\n  let top, left, bottom, right: CSSProperties['width'];\n\n  //! Position\n  // Top\n  if (position === 'top') {\n    bottom = window.innerHeight - triggerRect.top + offset;\n  }\n  // Bottom\n  if (position === 'bottom') {\n    top = triggerRect.bottom + offset;\n  }\n  // Left\n  if (position === 'left') {\n    right = window.innerWidth - triggerRect.left + offset;\n  }\n  // Right\n  if (position === 'right') {\n    left = triggerRect.right + offset;\n  }\n\n  //! Align\n  // Start\n  if (align === 'start') {\n    if (position === 'top' || position === 'bottom') {\n      left = triggerRect.left;\n    }\n    if (position === 'left' || position === 'right') {\n      top = triggerRect.top;\n    }\n  }\n  // End\n  if (align === 'end') {\n    if (position === 'top' || position === 'bottom') {\n      right = window.innerWidth - triggerRect.right;\n    }\n    if (position === 'left' || position === 'right') {\n      bottom = window.innerHeight - triggerRect.bottom;\n    }\n  }\n  // Center\n  if (align === 'center') {\n    if (position === 'top' || position === 'bottom') {\n      left =\n        triggerRect.right -\n        triggerRect.width / 2 -\n        (popoverElement?.clientWidth ?? 1) / 2;\n    }\n    if (position === 'left' || position === 'right') {\n      top =\n        triggerRect.bottom -\n        triggerRect.height / 2 -\n        (popoverElement?.clientHeight ?? 1) / 2;\n    }\n  }\n\n  return {\n    ...(top !== undefined && { top }),\n    ...(left !== undefined && { left }),\n    ...(bottom !== undefined && { bottom }),\n    ...(right !== undefined && { right }),\n  };\n}\n\nexport function buildPlacement(\n  placement: PopoverPlacement,\n  offset: number,\n  triggerRect: DOMRect,\n  popoverRect: DOMRect | undefined,\n): PopoverPlacement {\n  if (!popoverRect) {\n    return placement;\n  }\n\n  const [position, align] = placement.split('-') as [\n    PopoverPosition,\n    PopoverAlign,\n  ];\n\n  //! POSITION FITS CHECK\n  let fitPosition = position;\n\n  const fitsTop = triggerRect.top - popoverRect.height >= offset;\n  const fitsBottom =\n    window.innerHeight - triggerRect.bottom - popoverRect.height >= offset;\n  const fitsLeft = triggerRect.left - popoverRect.width >= offset;\n  const fitsRight =\n    window.innerWidth - triggerRect.right - popoverRect.width >= offset;\n\n  // Fits top check\n  if (position === 'top') {\n    if (fitsTop) {\n      fitPosition = 'top';\n    } else if (fitsBottom) {\n      fitPosition = 'bottom';\n    }\n  }\n\n  // Fits bottom check\n  if (position === 'bottom') {\n    if (fitsBottom) {\n      fitPosition = 'bottom';\n    } else if (fitsTop) {\n      fitPosition = 'top';\n    }\n  }\n\n  // Fits left check\n  if (position === 'left') {\n    if (fitsLeft) {\n      fitPosition = 'left';\n    } else if (fitsRight) {\n      fitPosition = 'right';\n    } else if (fitsBottom) {\n      fitPosition = 'bottom';\n    } else if (fitsTop) {\n      fitPosition = 'top';\n    }\n  }\n\n  // Fits right check\n  if (position === 'right') {\n    if (fitsRight) {\n      fitPosition = 'right';\n    } else if (fitsLeft) {\n      fitPosition = 'left';\n    } else if (fitsBottom) {\n      fitPosition = 'bottom';\n    } else if (fitsTop) {\n      fitPosition = 'top';\n    }\n  }\n\n  //! ALIGN FITS CHECK\n  let fitAlign = align;\n\n  // Fits start check\n  if (fitAlign === 'start') {\n    if (position === 'top' || position === 'bottom') {\n      const fits =\n        window.innerWidth - triggerRect.left - popoverRect.width >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n    if (position === 'left' || position === 'right') {\n      const fits =\n        window.innerHeight - triggerRect.top - popoverRect.height >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n  }\n\n  // Fits end check\n  if (fitAlign === 'end') {\n    if (position === 'top' || position === 'bottom') {\n      const fits = triggerRect.right - popoverRect.width >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n    if (position === 'left' || position === 'right') {\n      const fits = triggerRect.bottom - popoverRect.height >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n  }\n\n  // Fits center check\n  if (fitAlign === 'center') {\n    if (position === 'top' || position === 'bottom') {\n      const overflowsOnStart =\n        triggerRect.right - triggerRect.width / 2 < popoverRect.width / 2;\n      if (overflowsOnStart) {\n        fitAlign = 'start';\n      }\n\n      const overflowsOnEnd =\n        window.innerWidth - triggerRect.left - triggerRect.width / 2 <\n        popoverRect.width / 2;\n      if (overflowsOnEnd) {\n        fitAlign = 'end';\n      }\n    }\n\n    if (position === 'left' || position === 'right') {\n      const overflowsOnStart =\n        triggerRect.bottom - triggerRect.height / 2 < popoverRect.height / 2;\n      if (overflowsOnStart) {\n        fitAlign = 'start';\n      }\n\n      const overflowsOnEnd =\n        window.innerHeight - triggerRect.top - triggerRect.height / 2 <\n        popoverRect.height / 2;\n      if (overflowsOnEnd) {\n        fitAlign = 'end';\n      }\n    }\n  }\n\n  const fitPlacement = `${fitPosition}-${fitAlign}` as PopoverPlacement;\n\n  return fitPlacement;\n}\n\nlet debounceTimer: ReturnType<typeof setTimeout>;\nlet progressTimer: ReturnType<typeof setTimeout>;\nexport function debounceCallback<Args extends unknown[], Return>(\n  callback: (...args: Args) => Return,\n  delay: number,\n) {\n  let progress = 0;\n  let isInProgress = false;\n\n  const debouncedCallback = (...args: Args) => {\n    if (debounceTimer) clearTimeout(debounceTimer);\n    if (progressTimer) clearTimeout(progressTimer);\n\n    progress = 0;\n    isInProgress = false;\n\n    progressTimer = setTimeout(() => {\n      progress = 100;\n      isInProgress = true;\n\n      if (progressTimer) clearTimeout(progressTimer);\n    }, 10);\n\n    debounceTimer = setTimeout(() => {\n      callback(...args);\n\n      isInProgress = false;\n      if (debounceTimer) clearTimeout(debounceTimer);\n    }, delay);\n  };\n  return { callback: debouncedCallback, progress, isInProgress };\n}\n"
    },
    {
      "path": "components/ui/dropdown/types.ts",
      "type": "registry:ui",
      "target": "components/ui/dropdown/types.ts",
      "content": "import { ComponentPropsWithRef, ElementType } from 'react';\n\n// !Popover types\nexport type PopoverPosition = 'top' | 'bottom' | 'left' | 'right';\nexport type PopoverAlign = 'start' | 'end' | 'center';\nexport type PopoverPlacement = `${PopoverPosition}-${PopoverAlign}`;\n\nexport type Backdrop = 'transparent' | 'opaque' | 'blur';\n\ntype PopoverClassNames = {\n  base?: string;\n  trigger?: string;\n  backdrop?: string;\n  content?: string;\n};\n\nexport type PopoverProps = {\n  children?: React.ReactNode;\n  trigger?: React.ReactNode;\n  content?: React.ReactNode;\n  shouldFlip?: boolean;\n  shouldBlockScroll?: boolean;\n  shouldCloseOnBlur?: boolean;\n  shouldCloseOnEsc?: boolean;\n  shouldCloseOnScroll?: boolean;\n  backdrop?: Backdrop;\n  placement?: PopoverPlacement;\n  offset?: number;\n  isDisabled?: boolean;\n  isOpen?: boolean;\n  showArrow?: boolean;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onBlur?: () => void;\n  onOpenChange?: (isOpen: boolean) => void;\n  isNested?: boolean;\n  fullWidth?: boolean;\n  openOnHover?: boolean;\n  focusTriggerOnClose?: boolean;\n  delayShow?: number;\n  delayHide?: number;\n  hoverableContent?: boolean;\n  growContent?: boolean;\n  classNames?: PopoverClassNames;\n  focusTrapProps?: {\n    trapFocus?: boolean;\n    autoFocus?: boolean;\n  };\n};\n\nexport type PopoverTriggerProps = {\n  children: React.ReactNode;\n};\n\nexport type PopoverContentProps = {\n  children: React.ReactNode;\n};\n\nexport type PopoverComposition = {\n  /**\n   *  The component that triggers the popover\n   */\n  Trigger?: React.FC<PopoverTriggerProps>;\n\n  /**\n   * The component that contains the popover content.\n   */\n  Content?: React.FC<PopoverContentProps>;\n};\n\nexport type DropdownClassNames = {\n  popover?: PopoverClassNames;\n  divider?: DropdownDividerClassNames;\n  footer?: DropdownFooterClassNames;\n  header?: DropdownHeaderClassNames;\n  menu?: DropdownMenuClassNames;\n  item?: DropdownItemClassNames;\n  section?: DropdownSectionClassNames;\n};\n\ntype DropdownItemClassNames = {\n  base?: string;\n  startContent?: string;\n  mainContent?: string;\n  textContent?: string;\n  descriptionContent?: string;\n  endContent?: string;\n};\n\ntype DropdownSectionClassNames = {\n  base?: string;\n  title?: string;\n};\ntype DropdownTriggerClassNames = {\n  base?: string;\n};\ntype DropdownDividerClassNames = {\n  base?: string;\n};\ntype DropdownMenuClassNames = {\n  base?: string;\n};\ntype DropdownHeaderClassNames = {\n  base?: string;\n};\ntype DropdownFooterClassNames = {\n  base?: string;\n};\n// !Dropdown types\nexport type DropdownProps = {\n  shouldCloseOnSelection?: boolean;\n  caret?: React.ReactNode;\n  showCaret?: boolean;\n  classNames?: DropdownClassNames;\n  autoFocus?: ListAutoFocus;\n} & Omit<\n  PopoverProps,\n  'content' | 'delayShow' | 'delayHide' | 'hoverableContent' | 'classNames'\n>;\n\nexport type DropdownMenuProps = {\n  children: React.ReactNode;\n  isOpen?: boolean;\n  classNames?: DropdownMenuClassNames;\n};\n\nexport type DropdownHeaderProps = {\n  children: React.ReactNode;\n  isSticky?: boolean;\n  classNames?: DropdownHeaderClassNames;\n};\n\nexport type DropdownFooterProps = {\n  children: React.ReactNode;\n  isSticky?: boolean;\n  classNames?: DropdownFooterClassNames;\n};\n\nexport type DropdownSectionProps = {\n  children: React.ReactNode;\n  scrolling?: boolean;\n  title?: React.ReactNode;\n  isStickyTitle?: boolean;\n  infiniteScrollProps?: InfiniteScrollProps;\n  classNames?: DropdownSectionClassNames;\n};\n\nexport type DropdownItemProps<T extends ElementType = 'div'> = {\n  children: React.ReactNode;\n  isHighlighted?: boolean;\n  shouldCloseOnSelection?: boolean;\n  disabled?: boolean;\n  showDisabledStyles?: boolean;\n  startContent?: React.ReactNode;\n  endContent?: React.ReactNode;\n  as?: T;\n  classNames?: DropdownItemClassNames;\n  /**\n   * The description of the select.\n   */\n  description?: string;\n} & Omit<ComponentPropsWithRef<T>, 'children' | 'className'>;\n\nexport type DropdownTriggerProps = {\n  children: React.ReactNode;\n  classNames?: DropdownTriggerClassNames;\n};\n\nexport type DropdownDividerProps = {\n  classNames?: DropdownDividerClassNames;\n};\n\nexport type DropdownComposition = {\n  /**\n   * DropdownMenu is a container for DropdownSection and DropdownItem components.\n   */\n  Menu?: React.FC<DropdownMenuProps>;\n  /**\n   * DropdownHeader is a non-clickable element that provides context for the Dropdown.\n   */\n  Header?: React.FC<DropdownHeaderProps>;\n  /**\n   * DropdownFooter provides bottom space, usually used for actions.\n   */\n  Footer?: React.FC<DropdownFooterProps>;\n  /**\n   * DropdownSection groups DropdownItem components.\n   */\n  Section?: React.FC<DropdownSectionProps>;\n  /**\n   * DropdownItem is a clickable element that triggers an action.\n   */\n  Item?: React.FC<DropdownItemProps>;\n  /**\n   * DropdownTrigger is a clickable element that toggles the dropdown.\n   */\n  Trigger?: React.FC<DropdownTriggerProps>;\n\n  /**\n   * DropdownDivider is a visual separator between sections.\n   */\n  Divider?: React.FC<DropdownDividerProps>;\n};\n\nexport type SelectTruncate = {\n  /**\n   * Show selected value(s) in one line only\n   */\n  value?: boolean;\n  /**\n   * Truncate item text content\n   */\n  itemText?: boolean;\n  /**\n   * Truncate item description\n   */\n  itemDescription?: boolean;\n  /**\n   * Truncate section title\n   */\n  sectionTitle?: boolean;\n};\n\n// !Select types\n\nexport type SelectItemClassNames = {\n  /**\n   * The main slot for the listbox item. It wraps all the other slots.\n   */\n  base?: string;\n  /**\n   * `startContent`, `endContent` and `children` wrapper\n   */\n  contentWrapper?: string;\n  /**\n   * Left side of the content\n   */\n  startContent?: string;\n  /**\n   * Main content of the select item\n   */\n  mainContent?: string;\n  /**\n   * Main content of the select item\n   */\n  textContent?: string;\n  /**\n   * Main content of the select item\n   */\n  descriptionContent?: string;\n  /**\n   * Right side of the content\n   */\n  endContent?: string;\n  /**\n   * The selected icon slot. This is only visible when the item is selected - `âœ”`\n   */\n  selectedIcon?: string;\n};\n\nexport type SelectClassNames = {\n  /**\n   * The main wrapper of the select. This wraps the rest of the slots.\n   */\n  base?: string;\n  /**\n   * The label of the select.\n   */\n  label?: string;\n  /**\n   * The asterisk `*` after the label for `isRequired`.\n   */\n  requiredAsterisk?: string;\n  /**\n   * The trigger of the select. This wraps placeholder/value(s)/autocomplete-input and loading/caret.\n   */\n  trigger?: {\n    /**\n     * Trigger wrapper\n     */\n    base?: string;\n    /**\n     * The placeholder of the select.\n     */\n    placeholder?: string;\n    /**\n     * The default representation of selected value\n     */\n    valueText?: string;\n    valueChip?: string;\n    searchInput?: string;\n    /**\n     * The selector icon of the select. This is the icon that rotates when the select is open (data-open).\n     */\n    selectorIcon?: string;\n  };\n  /**\n   * The wrapper of the select content. This wraps the start/end content and the select value.\n   */\n  innerWrapper?: string;\n  /**\n   * The select value. This is also the slot that wraps the renderValue function result.\n   */\n  value?: string;\n  /**\n   * The wrapper of `topContent`, the listbox and `bottomContent`.\n   */\n  contentWrapper?: string;\n  /**\n   * The wrapper of the listbox. This wraps the listbox component, this slot is used on top of the scroll shadow component.\n   */\n  listboxWrapper?: string;\n  /**\n   * The listbox component. This is the component that wraps the select items.\n   */\n  listbox?: string;\n  /**\n   * The popover content slot. Use this to modify the popover content styles.\n   */\n  popover?: PopoverClassNames;\n  /**\n   * The wrapper of the helper text. This wraps the helper text and the error message.\n   */\n  helperWrapper?: string;\n  /**\n   * The description of the select.\n   */\n  description?: string;\n  /**\n   * The error message of the select.\n   */\n  errorMessage?: string;\n  /**\n   * Will apply classNames to all SelectItem-s\n   */\n  item?: SelectItemClassNames;\n  /**\n   * Will apply classNames to all SelectSection-s\n   */\n  section?: SelectSectionClassNames;\n};\n\nexport type SelectSectionClassNames = {\n  base?: string;\n  title?: string;\n};\n\nexport type RenderOption<T extends OptionItem> = ({\n  option,\n  currentOptions,\n}: {\n  option: T & { isSelected?: boolean; children?: React.ReactNode };\n  currentOptions?: (T & { isSelected?: boolean })[];\n}) => React.ReactNode;\n\nexport type SelectProps<T extends OptionItem> = {\n  onSelectionChange: OnSelectionChange<T>;\n  multiple?: boolean;\n  caret?: React.ReactNode;\n  showCaret?: boolean;\n  topContent?: React.ReactNode;\n  bottomContent?: React.ReactNode;\n  items?: T[];\n  placeholder?: string;\n  value?: T[];\n  defaultValue?: T[];\n  renderOption?: RenderOption<T>;\n  renderValue?: (selectedItems: T[]) => React.ReactNode;\n  children?:\n    | React.ReactNode\n    | ((item: T & { isSelected?: boolean }) => React.ReactNode);\n  label?: React.ReactNode;\n  isRequired?: boolean;\n  onClose?: (selectedItems?: T[]) => void;\n  openOnLabelClick?: boolean;\n  shouldCloseOnSelection?: boolean;\n  truncate?: SelectTruncate;\n  autoFocus?: ListAutoFocus;\n  search?: boolean | ((items: T[]) => T[]);\n  onSearchChange?: (searchQuery: string) => void;\n  description?: React.ReactNode;\n  errorMessage?: React.ReactNode;\n  noResultsMessage?: React.ReactNode;\n  infiniteScrollProps?: InfiniteScrollProps;\n  isLoading?: boolean;\n  /**\n   * Removes selected from the options list. Works only with `items` prop.\n   */\n  popOnSelection?: boolean;\n  /**\n   * Allows to set custom class names for the Select slots.\n   */\n  classNames?: SelectClassNames;\n} & Omit<\n  PopoverProps,\n  | 'content'\n  | 'delayShow'\n  | 'delayHide'\n  | 'hoverableContent'\n  | 'isNested'\n  | 'openOnHover'\n  | 'children'\n  | 'classNames'\n  | 'placement'\n  | 'onClose'\n>;\n\nexport type SelectItemProps<T extends OptionItem> = {\n  children: React.ReactNode;\n  shouldCloseOnSelection?: boolean;\n  showDisabledStyles?: boolean;\n  startContent?: React.ReactNode;\n  endContent?: React.ReactNode;\n  classNames?: SelectItemClassNames;\n  ref?: React.RefObject<HTMLLIElement | null>;\n} & T;\n\nexport type SelectTriggerProps = {\n  children: React.ReactNode;\n};\n\nexport type SelectSectionProps = {\n  children: React.ReactNode;\n  title?: React.ReactNode;\n  isStickyTitle?: boolean;\n  showDivider?: boolean;\n  classNames?: SelectSectionClassNames;\n};\n\nexport type SelectCompositionProps<T extends OptionItem> = {\n  /**\n   * SelectSection groups SelectItem components.\n   */\n  Section?: React.FC<SelectSectionProps>;\n  /**\n   * SelectItem is a clickable element that triggers the selection.\n   */\n  Item?: React.FC<SelectItemProps<T>>;\n  /**\n   * SelectDivider is a visual separator between sections.\n   */\n  Divider?: React.FC;\n};\n\nexport type OptionItem = {\n  value: string | number;\n  text: string;\n  textContent?: React.ReactNode;\n  description?: React.ReactNode;\n  disabled?: boolean;\n};\n\nexport type OnSelectionChange<T extends OptionItem> = (value: {\n  selectedOption?: T & { isSelected?: boolean };\n  selectedOptions: (T & { isSelected?: boolean })[];\n}) => void;\n\nexport type ListAutoFocus = 'first-item' | 'last-item' | 'menu' | 'none';\n\nexport type InfiniteScrollProps = {\n  onLoadMore: (search?: string) => void;\n  isLoading?: boolean;\n  hasMore: boolean;\n};\n"
    }
  ]
}