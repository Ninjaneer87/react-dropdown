{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "popover",
  "type": "registry:ui",
  "title": "Popover",
  "description": "A flexible popover component with positioning, focus trap, and scroll handling.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "components/ui/popover/Popover.tsx",
      "type": "registry:ui",
      "target": "components/ui/popover/Popover.tsx",
      "content": "/* eslint-disable react-hooks/refs */\nimport React, {\n  ReactNode,\n  useCallback,\n  useEffect,\n  useId,\n  useRef,\n  useState,\n} from 'react';\nimport { PopoverContext } from '../../context/PopoverContext';\nimport PopoverTrigger from './PopoverTrigger';\nimport { PopoverComposition, PopoverProps } from '../../types';\nimport { useDelayUnmount } from '../../hooks/useDelayUnmount';\nimport PopoverContent from './PopoverContent';\nimport {\n  createPositionFromPlacement,\n  Coords,\n  buildPlacement,\n  growContentPosition,\n  cn,\n} from '../../utils/common';\nimport ClientPortal from '../utility/ClientPortal';\nimport { useWindowResize } from '../../hooks/useWindowResize';\nimport { useFocusTrap } from '../../hooks/useFocusTrap';\nimport PopoverFocusTrapper from './PopoverFocusTrapper';\nimport {\n  PopoverRootContext,\n  usePopoverRootContext,\n} from '../../context/PopoverRootContext';\nimport { usePreventBodyScroll } from '../../hooks/usePreventBodyScroll';\nimport { useResizeObserver } from '../../hooks/useResizeObserver';\nimport { usePositionObserver } from '../../hooks/usePositionObserver';\nimport { Slot } from '@/components/utility/Slot';\n\nconst Popover = ({\n  children,\n  trigger,\n  content,\n  shouldFlip = true,\n  shouldBlockScroll = true,\n  shouldCloseOnScroll = !shouldBlockScroll,\n  shouldCloseOnBlur = true,\n  shouldCloseOnEsc = true,\n  backdrop,\n  isNested = false,\n  placement = 'bottom-center',\n  offset = 8,\n  // showArrow = false,\n  isDisabled,\n  isOpen: controlledIsOpen,\n  onOpen,\n  onClose,\n  onBlur,\n  onOpenChange,\n  openOnHover,\n  fullWidth = false,\n  focusTriggerOnClose = true,\n  delayShow = 0,\n  delayHide = 0,\n  hoverableContent = true,\n  growContent = false,\n  classNames,\n  focusTrapProps = {\n    autoFocus: true,\n    trapFocus: true,\n  },\n}: PopoverProps & PopoverComposition) => {\n  const { autoFocus, trapFocus } = focusTrapProps;\n  const popoverContentRef = useRef<HTMLDivElement>(null);\n  const popoverTriggerRef = useRef<HTMLDivElement>(null);\n  const showDelayRef = useRef<NodeJS.Timeout | null>(null);\n  const hideDelayRef = useRef<NodeJS.Timeout | null>(null);\n\n  const onOpenRef = useRef(onOpen);\n  const onCloseRef = useRef(onClose);\n  const onBlurRef = useRef(onBlur);\n  const onOpenChangeRef = useRef(onOpenChange);\n\n  const popoverRootContext = usePopoverRootContext();\n  const { isRootOpen, rootPopoverId } = popoverRootContext || {};\n  const isRootPopover = !popoverRootContext;\n  const popoverId = useId();\n\n  const [isOpen, setIsOpen] = useState(false);\n  const [isHoverOpen, setIsHoverOpen] = useState(false);\n  const [popoverContentCoords, setPopoverContentCoords] = useState<Coords>({});\n  const open = controlledIsOpen ?? isOpen;\n  const isExpanded = open || isHoverOpen;\n\n  const isMounted = useDelayUnmount(isExpanded, 150);\n\n  const isRootExpanded = isExpanded && (isRootPopover || !!isRootOpen);\n\n  let popoverTrigger: ReactNode | null = trigger ?? null;\n  let popoverContent: ReactNode | null = content ?? null;\n\n  const { firstFocusableItemRef, focusContainerRef, lastFocusableItemRef } =\n    useFocusTrap(open && !!trapFocus, !!autoFocus);\n\n  // Validate children\n  React.Children.forEach(children, (child) => {\n    if (!React.isValidElement(child)) return;\n\n    switch (child.type) {\n      case PopoverTrigger: {\n        if (popoverTrigger) {\n          throw new Error(\n            'Popover component can have only one PopoverTrigger or a \"trigger\" prop, not both',\n          );\n        }\n\n        popoverTrigger = child;\n        break;\n      }\n\n      case PopoverContent: {\n        if (popoverContent) {\n          throw new Error(\n            'Popover component can have only one PopoverContent or a \"content\" prop, not both',\n          );\n        }\n\n        popoverContent = child;\n        break;\n      }\n\n      default: {\n        throw new Error(\n          `Popover component only accepts PopoverTrigger and PopoverContent components as children`,\n        );\n      }\n    }\n  });\n\n  if (!popoverTrigger) {\n    throw new Error(\n      'Popover component requires a PopoverTrigger or a \"trigger\" prop',\n    );\n  }\n\n  if (!popoverContent) {\n    throw new Error('Popover component requires a PopoverContent');\n  }\n\n  const setContentCoords = useCallback(() => {\n    if (!isExpanded || !popoverTriggerRef.current || !popoverContentRef.current)\n      return;\n\n    const triggerRect = popoverTriggerRef.current.getBoundingClientRect();\n    const popoverRect = popoverContentRef.current.getBoundingClientRect();\n\n    if (growContent) {\n      const coords = growContentPosition(placement, offset, triggerRect);\n      setPopoverContentCoords(coords);\n\n      return;\n    }\n\n    const fitPlacement = shouldFlip\n      ? buildPlacement(placement, offset, triggerRect, popoverRect)\n      : placement;\n    const coords = createPositionFromPlacement(\n      fitPlacement,\n      offset,\n      triggerRect,\n      popoverContentRef.current,\n    );\n\n    setPopoverContentCoords(coords);\n  }, [placement, offset, shouldFlip, growContent, isExpanded]);\n\n  // Handle onClose\n  const handleClose = useCallback(\n    (focusTrigger = focusTriggerOnClose) => {\n      if (isDisabled) return;\n\n      if (onCloseRef.current) {\n        onCloseRef.current();\n      }\n\n      setIsOpen(false);\n      setIsHoverOpen(false);\n      onOpenChangeRef.current?.(false);\n\n      if (focusTrigger) {\n        // Delay focus to prevent the current keydown event from firing on the trigger\n        requestAnimationFrame(() => {\n          popoverTriggerRef.current?.focus();\n        });\n      }\n    },\n    [isDisabled, focusTriggerOnClose],\n  );\n\n  useWindowResize(setContentCoords);\n  usePreventBodyScroll(isRootExpanded && isRootPopover && shouldBlockScroll);\n  useResizeObserver({\n    element: popoverTriggerRef.current,\n    onResize: setContentCoords,\n  });\n  usePositionObserver({\n    element: popoverTriggerRef.current,\n    callback: setContentCoords,\n    isActive: isRootExpanded,\n  });\n\n  useEffect(() => {\n    onOpenRef.current = onOpen;\n    onCloseRef.current = onClose;\n    onBlurRef.current = onBlur;\n    onOpenChangeRef.current = onOpenChange;\n  }, [onOpen, onClose, onBlur, onOpenChange]);\n\n  // Handle onBlur\n  useEffect(() => {\n    if (isDisabled) return;\n    if (!isExpanded) return;\n\n    function handleClickOutside(event: MouseEvent) {\n      const popoverIdFromClosestTrigger = (event.target as Element)\n        .closest(`[data-popover-trigger-current-id]`)\n        ?.getAttribute('data-popover-trigger-current-id');\n      const popoverIdFromClosestContent = (event.target as Element)\n        .closest(`[data-popover-content-current-id]`)\n        ?.getAttribute('data-popover-content-current-id');\n      const id = popoverIdFromClosestTrigger || popoverIdFromClosestContent;\n\n      if (id && id !== popoverId) return;\n\n      const isPopoverTrigger = !!(event.target as Element).closest(\n        `[data-popover-trigger-current-id=\"${popoverId}\"]`,\n      );\n      const isPopoverContent = !!(event.target as Element).closest(\n        `[data-popover-content-current-id=\"${popoverId}\"]`,\n      );\n\n      if (isPopoverTrigger || isPopoverContent) {\n        return;\n      }\n\n      if (onBlurRef.current) onBlurRef.current();\n      if (shouldCloseOnBlur) handleClose();\n    }\n\n    document.addEventListener('mousedown', handleClickOutside);\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [shouldCloseOnBlur, isExpanded, isDisabled, handleClose, popoverId]);\n\n  // Handle position and scroll\n  useEffect(() => {\n    if (isExpanded) {\n      setContentCoords();\n    }\n  }, [isExpanded, setContentCoords]);\n\n  useEffect(() => {\n    if (!isExpanded) return;\n\n    function handleScroll() {\n      if (shouldCloseOnScroll) {\n        handleClose();\n      }\n      setContentCoords();\n    }\n\n    document.addEventListener('scroll', handleScroll);\n\n    return () => {\n      document.removeEventListener('scroll', handleScroll);\n    };\n  }, [isExpanded, shouldCloseOnScroll, handleClose, setContentCoords]);\n\n  // Handle onOpenChange\n  const handleToggle = useCallback(() => {\n    if (isDisabled) return;\n\n    if (onOpenChangeRef.current) {\n      onOpenChangeRef.current(!open);\n    }\n\n    if (open) {\n      handleClose();\n      return;\n    }\n\n    onOpenRef.current?.();\n\n    setIsOpen((prev) => !prev);\n  }, [isDisabled, open, handleClose]);\n\n  const handleOpen = useCallback(() => {\n    if (isDisabled || open) return;\n\n    if (onOpenChangeRef.current) onOpenChangeRef.current(true);\n    if (onOpenRef.current) onOpenRef.current();\n    setIsOpen(true);\n  }, [isDisabled, open]);\n\n  const handleBackdropClick = useCallback(() => {\n    if (shouldCloseOnBlur) {\n      handleClose();\n    }\n  }, [handleClose, shouldCloseOnBlur]);\n\n  const onTriggerKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (event.key === 'Enter') {\n        // Only toggle if the event originated from the trigger itself\n        if (event.target !== event.currentTarget) return;\n\n        event.preventDefault();\n        handleToggle();\n      }\n    },\n    [handleToggle],\n  );\n\n  useEffect(() => {\n    if (!isExpanded) {\n      return;\n    }\n\n    function onPopoverKeyDown(event: KeyboardEvent) {\n      if (event.key === 'Escape' && shouldCloseOnEsc) {\n        const openPopovers = [\n          ...document.querySelectorAll(`[data-popover-content-current-id]`),\n        ];\n        const lastOpenedPopover = openPopovers[openPopovers.length - 1] as\n          | HTMLDivElement\n          | undefined;\n        const currentPopoverId = lastOpenedPopover?.getAttribute(\n          `data-popover-content-current-id`,\n        );\n\n        if (currentPopoverId && currentPopoverId !== popoverId) return;\n        handleClose();\n      }\n    }\n    document.addEventListener('keydown', onPopoverKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onPopoverKeyDown);\n    };\n  }, [shouldCloseOnEsc, isExpanded, handleClose, popoverId]);\n\n  const handleMouseEnter = useCallback(() => {\n    if (isDisabled) return;\n\n    if (showDelayRef.current) clearTimeout(showDelayRef.current);\n    if (hideDelayRef.current) clearTimeout(hideDelayRef.current);\n\n    showDelayRef.current = setTimeout(() => {\n      setIsHoverOpen(true);\n\n      if (isRootPopover && openOnHover) onOpenRef.current?.();\n    }, delayShow);\n  }, [isDisabled, isRootPopover, openOnHover, delayShow]);\n\n  const handleMouseLeave = useCallback(() => {\n    if (isDisabled) return;\n\n    if (showDelayRef.current) clearTimeout(showDelayRef.current);\n    if (hideDelayRef.current) clearTimeout(hideDelayRef.current);\n\n    hideDelayRef.current = setTimeout(() => {\n      setIsHoverOpen(false);\n\n      if (isRootPopover && openOnHover) onCloseRef.current?.();\n    }, delayHide);\n  }, [isDisabled, isRootPopover, openOnHover, delayHide]);\n\n  const baseClassName = cn('relative', fullWidth ? 'w-full' : 'w-fit');\n  const triggerClassName = cn(\n    'flex items-center gap-2',\n    !isDisabled ? 'cursor-pointer' : '',\n    'grow w-full',\n  );\n  const contentClassName = cn(\n    'fixed z-10',\n    isRootExpanded || (isExpanded && !isNested) ? 'scale-in' : 'scale-out',\n    'transition-opacity p-2 bg-white text-gray-800 rounded-lg shadow-md',\n  );\n  const backdropClassName = cn(\n    'fixed z-0 inset-0',\n    backdrop !== 'transparent' ? 'bg-black/30' : '',\n    backdrop === 'blur' ? 'backdrop-blur-xs' : '',\n    isRootExpanded ? 'fade-in' : 'fade-out',\n  );\n\n  const popoverJSX = (\n    <PopoverContext.Provider\n      value={{ isOpen: isExpanded, handleClose, popoverId, handleOpen }}\n    >\n      <>\n        <ClientPortal>\n          {isMounted && !!backdrop && (\n            <div\n              className={cn(backdropClassName, classNames?.backdrop)}\n              onClick={(e) => {\n                e.stopPropagation();\n                handleBackdropClick();\n              }}\n            />\n          )}\n        </ClientPortal>\n\n        <div\n          className={cn(baseClassName, classNames?.base)}\n          onScroll={(e) => {\n            e.preventDefault();\n            e.stopPropagation();\n          }}\n          {...(openOnHover &&\n            hoverableContent && {\n              onMouseEnter: handleMouseEnter,\n              onMouseLeave: handleMouseLeave,\n            })}\n        >\n          <Slot\n            onClick={(e: React.MouseEvent) => {\n              e?.stopPropagation();\n              handleToggle();\n            }}\n            data-popover-trigger-root-id={rootPopoverId ?? popoverId}\n            data-trigger-open={isExpanded}\n            onKeyDown={onTriggerKeyDown}\n            tabIndex={0}\n            className={cn(triggerClassName, classNames?.trigger)}\n            ref={popoverTriggerRef}\n            {...(openOnHover &&\n              !hoverableContent && {\n                onMouseEnter: handleMouseEnter,\n                onMouseLeave: handleMouseLeave,\n              })}\n          >\n            {popoverTrigger}\n          </Slot>\n\n          <ClientPortal>\n            {(isMounted || isExpanded) && (\n              <div\n                data-popover-content-root-id={rootPopoverId ?? popoverId}\n                data-popover-content-current-id={popoverId}\n                className={cn(contentClassName, classNames?.content)}\n                style={popoverContentCoords}\n                onClick={(e) => e.stopPropagation()}\n                ref={(node) => {\n                  if (!node) return;\n\n                  popoverContentRef.current = node;\n                  focusContainerRef.current = node;\n                }}\n              >\n                <PopoverFocusTrapper ref={firstFocusableItemRef} />\n                {popoverContent}\n                <PopoverFocusTrapper ref={lastFocusableItemRef} />\n              </div>\n            )}\n          </ClientPortal>\n        </div>\n      </>\n    </PopoverContext.Provider>\n  );\n\n  if (isNested) {\n    return popoverJSX;\n  }\n\n  return (\n    <PopoverRootContext.Provider\n      value={{\n        isRootOpen: isExpanded,\n        handleCloseRoot: handleClose,\n        rootPopoverId: popoverId,\n      }}\n    >\n      {popoverJSX}\n    </PopoverRootContext.Provider>\n  );\n};\n\nPopover.Content = PopoverContent;\nPopover.Trigger = PopoverTrigger;\n\nexport default Popover;\n"
    },
    {
      "path": "components/ui/popover/PopoverContent.tsx",
      "type": "registry:ui",
      "target": "components/ui/popover/PopoverContent.tsx",
      "content": "import { PopoverContentProps } from '../../types';\nimport { usePopoverContext } from '../../context/PopoverContext';\n\nfunction PopoverContent({ children }: PopoverContentProps) {\n  const popoverContext = usePopoverContext();\n\n  if (!popoverContext) {\n    throw new Error('PopoverContent should be used within a Popover component');\n  }\n\n  return children;\n}\n\nexport default PopoverContent;\n"
    },
    {
      "path": "components/ui/popover/PopoverTrigger.tsx",
      "type": "registry:ui",
      "target": "components/ui/popover/PopoverTrigger.tsx",
      "content": "import React from 'react';\nimport { PopoverTriggerProps } from '../../types';\nimport { usePopoverContext } from '../../context/PopoverContext';\nimport { Slot } from '@/components/utility/Slot';\n\nfunction PopoverTrigger({ children, ...rest }: PopoverTriggerProps) {\n  const popoverContext = usePopoverContext();\n\n  if (!popoverContext) {\n    throw new Error('PopoverTrigger should be used within a Popover component');\n  }\n\n  const child = React.Children.only(children);\n\n  if (React.isValidElement(child) && child.type === React.Fragment) {\n    throw new Error(\n      'PopoverTrigger requires a single element, not a React.Fragment',\n    );\n  }\n\n  return <Slot {...rest}>{child}</Slot>;\n}\n\nexport default PopoverTrigger;\n"
    },
    {
      "path": "components/ui/popover/PopoverFocusTrapper.tsx",
      "type": "registry:ui",
      "target": "components/ui/popover/PopoverFocusTrapper.tsx",
      "content": "import React, { ComponentPropsWithRef } from 'react';\nimport { usePopoverContext } from '../../context/PopoverContext';\n\ntype Props = ComponentPropsWithRef<'div'>;\nconst PopoverFocusTrapper = React.forwardRef<HTMLDivElement, Props>(\n  (props, ref) => {\n    const popoverContext = usePopoverContext();\n    if (!popoverContext) {\n      throw new Error(\n        'PopoverFocusTrapper should be used within a Popover component',\n      );\n    }\n\n    const { popoverId } = popoverContext;\n\n    return (\n      <div\n        data-focus-trapper={popoverId}\n        className=\"absolute w-0 h-0\"\n        tabIndex={0}\n        {...props}\n        ref={ref}\n      />\n    );\n  },\n);\n\nPopoverFocusTrapper.displayName = 'PopoverFocusTrapper';\n\nexport default PopoverFocusTrapper;\n"
    },
    {
      "path": "components/ui/popover/index.ts",
      "type": "registry:ui",
      "target": "components/ui/popover/index.ts",
      "content": "export { default as Popover } from './Popover';\nexport { default as PopoverContent } from './PopoverContent';\nexport { default as PopoverTrigger } from './PopoverTrigger';\n"
    },
    {
      "path": "components/ui/popover/context/PopoverContext.ts",
      "type": "registry:ui",
      "target": "components/ui/popover/context/PopoverContext.ts",
      "content": "import { createContext, useContext } from 'react';\n\ntype PopoverContextType = {\n  popoverId: string;\n  isOpen: boolean;\n  handleClose: (focusTrigger?: boolean) => void;\n  handleOpen: () => void;\n};\n\nexport const PopoverContext = createContext<PopoverContextType | null>(null);\n\nexport const usePopoverContext = () => useContext(PopoverContext);\n"
    },
    {
      "path": "components/ui/popover/context/PopoverRootContext.ts",
      "type": "registry:ui",
      "target": "components/ui/popover/context/PopoverRootContext.ts",
      "content": "import { createContext, useContext } from 'react';\n\ntype PopoverRootContextType = {\n  rootPopoverId: string;\n  isRootOpen: boolean;\n  handleCloseRoot: (focusTrigger?: boolean) => void;\n};\n\nexport const PopoverRootContext = createContext<PopoverRootContextType | null>(\n  null,\n);\n\nexport const usePopoverRootContext = () => useContext(PopoverRootContext);\n"
    },
    {
      "path": "hooks/useFocusTrap.ts",
      "type": "registry:ui",
      "target": "hooks/useFocusTrap.ts",
      "content": "import { useEffect, useRef } from 'react';\n\nexport function useFocusTrap(isActive: boolean, shouldAutoFocus = true) {\n  const focusContainerRef = useRef<HTMLDivElement>(null);\n  const firstFocusableItemRef = useRef<HTMLDivElement>(null);\n  const lastFocusableItemRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!isActive) {\n      return;\n    }\n\n    function trapFocus(event: KeyboardEvent) {\n      if (event.key !== 'Tab') return;\n\n      const firstElement = firstFocusableItemRef.current;\n      const lastElement = lastFocusableItemRef.current;\n\n      if (!firstElement || !lastElement) return;\n\n      if (event.shiftKey && document.activeElement === firstElement) {\n        event.preventDefault();\n        lastElement.focus();\n      } else if (!event.shiftKey && document.activeElement === lastElement) {\n        event.preventDefault();\n        firstElement.focus();\n      }\n    }\n\n    if (shouldAutoFocus) {\n      firstFocusableItemRef.current?.focus(); // Auto-focus first element when mounted\n    }\n\n    document.addEventListener('keydown', trapFocus);\n\n    return () => {\n      document.removeEventListener('keydown', trapFocus);\n    };\n  }, [isActive, shouldAutoFocus]);\n\n  return { focusContainerRef, firstFocusableItemRef, lastFocusableItemRef };\n}\n"
    },
    {
      "path": "hooks/usePreventBodyScroll.ts",
      "type": "registry:ui",
      "target": "hooks/usePreventBodyScroll.ts",
      "content": "import { useEffect } from 'react';\n\nexport function usePreventBodyScroll(shouldPrevent: boolean) {\n  useEffect(() => {\n    const currentBodyOverflowY = window.getComputedStyle(\n      document.body,\n    ).overflowY;\n\n    if (shouldPrevent) {\n      document.body.style.overflowY = 'hidden';\n    }\n\n    return () => {\n      if (shouldPrevent) {\n        document.body.style.overflowY = currentBodyOverflowY;\n      }\n    };\n  }, [shouldPrevent]);\n}\n"
    },
    {
      "path": "hooks/usePositionObserver.ts",
      "type": "registry:ui",
      "target": "hooks/usePositionObserver.ts",
      "content": "import { useEffect, useRef } from 'react';\n\n/**\n * Observes an element's viewport position (top/left) and calls a callback\n * if the position changes, which is useful for detecting movement caused\n * by DOM changes outside of the element's subtree.\n * * @param element The HTML element to observe.\n * @param callback The function to call when the position changes.\n */\nexport const usePositionObserver = ({\n  element,\n  callback,\n  isActive,\n}: {\n  element: HTMLElement | null;\n  callback: () => void;\n  isActive: boolean;\n}) => {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  const lastPositionRef = useRef({ top: 0, left: 0 });\n  const animationFrameRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    if (!isActive || !element) {\n      // Clean up any existing frame if the element is null\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      return;\n    }\n\n    // Initialize the last known position\n    const rect = element.getBoundingClientRect();\n    lastPositionRef.current = { top: rect.top, left: rect.left };\n\n    const checkPosition = () => {\n      const currentRect = element.getBoundingClientRect();\n      const currentTop = currentRect.top;\n      const currentLeft = currentRect.left;\n\n      const lastTop = lastPositionRef.current.top;\n      const lastLeft = lastPositionRef.current.left;\n\n      // Check for position change (only interested in vertical change here, but checking both)\n      if (currentTop !== lastTop || currentLeft !== lastLeft) {\n        // Position has moved due to reflow\n        callbackRef.current();\n      }\n\n      // Update the last known position for the next frame\n      lastPositionRef.current = { top: currentTop, left: currentLeft };\n\n      // Schedule the check for the next animation frame\n      animationFrameRef.current = requestAnimationFrame(checkPosition);\n    };\n\n    // Start the continuous check\n    animationFrameRef.current = requestAnimationFrame(checkPosition);\n\n    return () => {\n      // Cleanup: Stop the animation frame loop when the component unmounts\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [element, isActive]);\n};\n"
    },
    {
      "path": "hooks/useDelayUnmount.ts",
      "type": "registry:ui",
      "target": "hooks/useDelayUnmount.ts",
      "content": "/* eslint-disable react-hooks/set-state-in-effect */\nimport { useEffect, useState } from 'react';\n\nexport function useDelayUnmount(isMounted: boolean, delayTime: number) {\n  const [shouldRender, setShouldRender] = useState(false);\n\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout;\n\n    if (isMounted && !shouldRender) {\n      setShouldRender(true);\n    } else if (!isMounted && shouldRender) {\n      timeoutId = setTimeout(() => setShouldRender(false), delayTime);\n    }\n\n    return () => clearTimeout(timeoutId);\n  }, [isMounted, delayTime, shouldRender]);\n\n  return shouldRender;\n}\n"
    },
    {
      "path": "hooks/useResizeObserver.ts",
      "type": "registry:ui",
      "target": "hooks/useResizeObserver.ts",
      "content": "import { useEffect, useRef } from 'react';\n\ntype Props<T extends Element> = {\n  element: T | null;\n  onResize: (entries?: ResizeObserverEntry[]) => void;\n};\nexport const useResizeObserver = <T extends Element>({\n  element,\n  onResize,\n}: Props<T>) => {\n  const onResizeRef = useRef(onResize);\n\n  useEffect(() => {\n    onResizeRef.current = onResize;\n  }, [onResize]);\n\n  useEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const observer = new ResizeObserver((entries) => {\n      onResizeRef.current(entries);\n    });\n\n    observer.observe(element);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [element]);\n};\n"
    },
    {
      "path": "hooks/useWindowResize.ts",
      "type": "registry:ui",
      "target": "hooks/useWindowResize.ts",
      "content": "import { useEffect, useRef } from 'react';\n\nexport function useWindowResize(callback: (e?: UIEvent) => void) {\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    const onResize = () => {\n      if (!callbackRef.current) {\n        return;\n      }\n\n      callbackRef.current();\n    };\n\n    window.addEventListener('resize', onResize);\n\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n}\n"
    },
    {
      "path": "components/ui/popover/utils/common.ts",
      "type": "registry:ui",
      "target": "components/ui/popover/utils/common.ts",
      "content": "import { CSSProperties } from 'react';\nimport { PopoverAlign, PopoverPlacement, PopoverPosition } from '../types';\nimport { type ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(...inputs));\n}\n\nexport type Coords = {\n  top?: CSSProperties['width'];\n  left?: CSSProperties['width'];\n  bottom?: CSSProperties['width'];\n  right?: CSSProperties['width'];\n};\n\nexport function growContentPosition(\n  placement: PopoverPlacement,\n  offset: number,\n  triggerRect: DOMRect,\n): Coords {\n  const [position] = placement.split('-') as [PopoverPosition, PopoverAlign];\n\n  let top, left, bottom, right: CSSProperties['width'];\n\n  //! Position\n  // Top\n  if (position === 'top') {\n    bottom = window.innerHeight - triggerRect.top + offset;\n    left = 0;\n    right = 0;\n  }\n  // Bottom\n  if (position === 'bottom') {\n    top = triggerRect.bottom + offset;\n    left = 0;\n    right = 0;\n  }\n  // Left\n  if (position === 'left') {\n    right = window.innerWidth - triggerRect.left + offset;\n    top = 0;\n    bottom = 0;\n    left = 0;\n  }\n  // Right\n  if (position === 'right') {\n    left = triggerRect.right + offset;\n    top = 0;\n    bottom = 0;\n    right = 0;\n  }\n\n  return {\n    ...(top !== undefined && { top }),\n    ...(left !== undefined && { left }),\n    ...(bottom !== undefined && { bottom }),\n    ...(right !== undefined && { right }),\n  };\n}\n\nexport function createPositionFromPlacement(\n  placement: PopoverPlacement,\n  offset: number,\n  triggerRect: DOMRect,\n  popoverElement: HTMLDivElement | undefined,\n): Coords {\n  const [position, align] = placement.split('-') as [\n    PopoverPosition,\n    PopoverAlign,\n  ];\n\n  let top, left, bottom, right: CSSProperties['width'];\n\n  //! Position\n  // Top\n  if (position === 'top') {\n    bottom = window.innerHeight - triggerRect.top + offset;\n  }\n  // Bottom\n  if (position === 'bottom') {\n    top = triggerRect.bottom + offset;\n  }\n  // Left\n  if (position === 'left') {\n    right = window.innerWidth - triggerRect.left + offset;\n  }\n  // Right\n  if (position === 'right') {\n    left = triggerRect.right + offset;\n  }\n\n  //! Align\n  // Start\n  if (align === 'start') {\n    if (position === 'top' || position === 'bottom') {\n      left = triggerRect.left;\n    }\n    if (position === 'left' || position === 'right') {\n      top = triggerRect.top;\n    }\n  }\n  // End\n  if (align === 'end') {\n    if (position === 'top' || position === 'bottom') {\n      right = window.innerWidth - triggerRect.right;\n    }\n    if (position === 'left' || position === 'right') {\n      bottom = window.innerHeight - triggerRect.bottom;\n    }\n  }\n  // Center\n  if (align === 'center') {\n    if (position === 'top' || position === 'bottom') {\n      left =\n        triggerRect.right -\n        triggerRect.width / 2 -\n        (popoverElement?.clientWidth ?? 1) / 2;\n    }\n    if (position === 'left' || position === 'right') {\n      top =\n        triggerRect.bottom -\n        triggerRect.height / 2 -\n        (popoverElement?.clientHeight ?? 1) / 2;\n    }\n  }\n\n  return {\n    ...(top !== undefined && { top }),\n    ...(left !== undefined && { left }),\n    ...(bottom !== undefined && { bottom }),\n    ...(right !== undefined && { right }),\n  };\n}\n\nexport function buildPlacement(\n  placement: PopoverPlacement,\n  offset: number,\n  triggerRect: DOMRect,\n  popoverRect: DOMRect | undefined,\n): PopoverPlacement {\n  if (!popoverRect) {\n    return placement;\n  }\n\n  const [position, align] = placement.split('-') as [\n    PopoverPosition,\n    PopoverAlign,\n  ];\n\n  //! POSITION FITS CHECK\n  let fitPosition = position;\n\n  const fitsTop = triggerRect.top - popoverRect.height >= offset;\n  const fitsBottom =\n    window.innerHeight - triggerRect.bottom - popoverRect.height >= offset;\n  const fitsLeft = triggerRect.left - popoverRect.width >= offset;\n  const fitsRight =\n    window.innerWidth - triggerRect.right - popoverRect.width >= offset;\n\n  // Fits top check\n  if (position === 'top') {\n    if (fitsTop) {\n      fitPosition = 'top';\n    } else if (fitsBottom) {\n      fitPosition = 'bottom';\n    }\n  }\n\n  // Fits bottom check\n  if (position === 'bottom') {\n    if (fitsBottom) {\n      fitPosition = 'bottom';\n    } else if (fitsTop) {\n      fitPosition = 'top';\n    }\n  }\n\n  // Fits left check\n  if (position === 'left') {\n    if (fitsLeft) {\n      fitPosition = 'left';\n    } else if (fitsRight) {\n      fitPosition = 'right';\n    } else if (fitsBottom) {\n      fitPosition = 'bottom';\n    } else if (fitsTop) {\n      fitPosition = 'top';\n    }\n  }\n\n  // Fits right check\n  if (position === 'right') {\n    if (fitsRight) {\n      fitPosition = 'right';\n    } else if (fitsLeft) {\n      fitPosition = 'left';\n    } else if (fitsBottom) {\n      fitPosition = 'bottom';\n    } else if (fitsTop) {\n      fitPosition = 'top';\n    }\n  }\n\n  //! ALIGN FITS CHECK\n  let fitAlign = align;\n\n  // Fits start check\n  if (fitAlign === 'start') {\n    if (position === 'top' || position === 'bottom') {\n      const fits =\n        window.innerWidth - triggerRect.left - popoverRect.width >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n    if (position === 'left' || position === 'right') {\n      const fits =\n        window.innerHeight - triggerRect.top - popoverRect.height >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n  }\n\n  // Fits end check\n  if (fitAlign === 'end') {\n    if (position === 'top' || position === 'bottom') {\n      const fits = triggerRect.right - popoverRect.width >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n    if (position === 'left' || position === 'right') {\n      const fits = triggerRect.bottom - popoverRect.height >= 0;\n      if (!fits) {\n        fitAlign = 'center';\n      }\n    }\n  }\n\n  // Fits center check\n  if (fitAlign === 'center') {\n    if (position === 'top' || position === 'bottom') {\n      const overflowsOnStart =\n        triggerRect.right - triggerRect.width / 2 < popoverRect.width / 2;\n      if (overflowsOnStart) {\n        fitAlign = 'start';\n      }\n\n      const overflowsOnEnd =\n        window.innerWidth - triggerRect.left - triggerRect.width / 2 <\n        popoverRect.width / 2;\n      if (overflowsOnEnd) {\n        fitAlign = 'end';\n      }\n    }\n\n    if (position === 'left' || position === 'right') {\n      const overflowsOnStart =\n        triggerRect.bottom - triggerRect.height / 2 < popoverRect.height / 2;\n      if (overflowsOnStart) {\n        fitAlign = 'start';\n      }\n\n      const overflowsOnEnd =\n        window.innerHeight - triggerRect.top - triggerRect.height / 2 <\n        popoverRect.height / 2;\n      if (overflowsOnEnd) {\n        fitAlign = 'end';\n      }\n    }\n  }\n\n  const fitPlacement = `${fitPosition}-${fitAlign}` as PopoverPlacement;\n\n  return fitPlacement;\n}\n\nlet debounceTimer: ReturnType<typeof setTimeout>;\nlet progressTimer: ReturnType<typeof setTimeout>;\nexport function debounceCallback<Args extends unknown[], Return>(\n  callback: (...args: Args) => Return,\n  delay: number,\n) {\n  let progress = 0;\n  let isInProgress = false;\n\n  const debouncedCallback = (...args: Args) => {\n    if (debounceTimer) clearTimeout(debounceTimer);\n    if (progressTimer) clearTimeout(progressTimer);\n\n    progress = 0;\n    isInProgress = false;\n\n    progressTimer = setTimeout(() => {\n      progress = 100;\n      isInProgress = true;\n\n      if (progressTimer) clearTimeout(progressTimer);\n    }, 10);\n\n    debounceTimer = setTimeout(() => {\n      callback(...args);\n\n      isInProgress = false;\n      if (debounceTimer) clearTimeout(debounceTimer);\n    }, delay);\n  };\n  return { callback: debouncedCallback, progress, isInProgress };\n}\n"
    },
    {
      "path": "components/ui/popover/types.ts",
      "type": "registry:ui",
      "target": "components/ui/popover/types.ts",
      "content": "import { ComponentPropsWithRef, ElementType } from 'react';\n\n// !Popover types\nexport type PopoverPosition = 'top' | 'bottom' | 'left' | 'right';\nexport type PopoverAlign = 'start' | 'end' | 'center';\nexport type PopoverPlacement = `${PopoverPosition}-${PopoverAlign}`;\n\nexport type Backdrop = 'transparent' | 'opaque' | 'blur';\n\ntype PopoverClassNames = {\n  base?: string;\n  trigger?: string;\n  backdrop?: string;\n  content?: string;\n};\n\nexport type PopoverProps = {\n  children?: React.ReactNode;\n  trigger?: React.ReactNode;\n  content?: React.ReactNode;\n  shouldFlip?: boolean;\n  shouldBlockScroll?: boolean;\n  shouldCloseOnBlur?: boolean;\n  shouldCloseOnEsc?: boolean;\n  shouldCloseOnScroll?: boolean;\n  backdrop?: Backdrop;\n  placement?: PopoverPlacement;\n  offset?: number;\n  isDisabled?: boolean;\n  isOpen?: boolean;\n  showArrow?: boolean;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onBlur?: () => void;\n  onOpenChange?: (isOpen: boolean) => void;\n  isNested?: boolean;\n  fullWidth?: boolean;\n  openOnHover?: boolean;\n  focusTriggerOnClose?: boolean;\n  delayShow?: number;\n  delayHide?: number;\n  hoverableContent?: boolean;\n  growContent?: boolean;\n  classNames?: PopoverClassNames;\n  focusTrapProps?: {\n    trapFocus?: boolean;\n    autoFocus?: boolean;\n  };\n};\n\nexport type PopoverTriggerProps = {\n  children: React.ReactNode;\n};\n\nexport type PopoverContentProps = {\n  children: React.ReactNode;\n};\n\nexport type PopoverComposition = {\n  /**\n   *  The component that triggers the popover\n   */\n  Trigger?: React.FC<PopoverTriggerProps>;\n\n  /**\n   * The component that contains the popover content.\n   */\n  Content?: React.FC<PopoverContentProps>;\n};\n\nexport type DropdownClassNames = {\n  popover?: PopoverClassNames;\n  divider?: DropdownDividerClassNames;\n  footer?: DropdownFooterClassNames;\n  header?: DropdownHeaderClassNames;\n  menu?: DropdownMenuClassNames;\n  item?: DropdownItemClassNames;\n  section?: DropdownSectionClassNames;\n};\n\ntype DropdownItemClassNames = {\n  base?: string;\n  startContent?: string;\n  mainContent?: string;\n  textContent?: string;\n  descriptionContent?: string;\n  endContent?: string;\n};\n\ntype DropdownSectionClassNames = {\n  base?: string;\n  title?: string;\n};\ntype DropdownTriggerClassNames = {\n  base?: string;\n};\ntype DropdownDividerClassNames = {\n  base?: string;\n};\ntype DropdownMenuClassNames = {\n  base?: string;\n};\ntype DropdownHeaderClassNames = {\n  base?: string;\n};\ntype DropdownFooterClassNames = {\n  base?: string;\n};\n// !Dropdown types\nexport type DropdownProps = {\n  shouldCloseOnSelection?: boolean;\n  caret?: React.ReactNode;\n  showCaret?: boolean;\n  classNames?: DropdownClassNames;\n  autoFocus?: ListAutoFocus;\n} & Omit<\n  PopoverProps,\n  'content' | 'delayShow' | 'delayHide' | 'hoverableContent' | 'classNames'\n>;\n\nexport type DropdownMenuProps = {\n  children: React.ReactNode;\n  isOpen?: boolean;\n  classNames?: DropdownMenuClassNames;\n};\n\nexport type DropdownHeaderProps = {\n  children: React.ReactNode;\n  isSticky?: boolean;\n  classNames?: DropdownHeaderClassNames;\n};\n\nexport type DropdownFooterProps = {\n  children: React.ReactNode;\n  isSticky?: boolean;\n  classNames?: DropdownFooterClassNames;\n};\n\nexport type DropdownSectionProps = {\n  children: React.ReactNode;\n  scrolling?: boolean;\n  title?: React.ReactNode;\n  isStickyTitle?: boolean;\n  infiniteScrollProps?: InfiniteScrollProps;\n  classNames?: DropdownSectionClassNames;\n};\n\nexport type DropdownItemProps<T extends ElementType = 'div'> = {\n  children: React.ReactNode;\n  isHighlighted?: boolean;\n  shouldCloseOnSelection?: boolean;\n  disabled?: boolean;\n  showDisabledStyles?: boolean;\n  startContent?: React.ReactNode;\n  endContent?: React.ReactNode;\n  as?: T;\n  classNames?: DropdownItemClassNames;\n  /**\n   * The description of the select.\n   */\n  description?: string;\n} & Omit<ComponentPropsWithRef<T>, 'children' | 'className'>;\n\nexport type DropdownTriggerProps = {\n  children: React.ReactNode;\n  classNames?: DropdownTriggerClassNames;\n};\n\nexport type DropdownDividerProps = {\n  classNames?: DropdownDividerClassNames;\n};\n\nexport type DropdownComposition = {\n  /**\n   * DropdownMenu is a container for DropdownSection and DropdownItem components.\n   */\n  Menu?: React.FC<DropdownMenuProps>;\n  /**\n   * DropdownHeader is a non-clickable element that provides context for the Dropdown.\n   */\n  Header?: React.FC<DropdownHeaderProps>;\n  /**\n   * DropdownFooter provides bottom space, usually used for actions.\n   */\n  Footer?: React.FC<DropdownFooterProps>;\n  /**\n   * DropdownSection groups DropdownItem components.\n   */\n  Section?: React.FC<DropdownSectionProps>;\n  /**\n   * DropdownItem is a clickable element that triggers an action.\n   */\n  Item?: React.FC<DropdownItemProps>;\n  /**\n   * DropdownTrigger is a clickable element that toggles the dropdown.\n   */\n  Trigger?: React.FC<DropdownTriggerProps>;\n\n  /**\n   * DropdownDivider is a visual separator between sections.\n   */\n  Divider?: React.FC<DropdownDividerProps>;\n};\n\nexport type SelectTruncate = {\n  /**\n   * Show selected value(s) in one line only\n   */\n  value?: boolean;\n  /**\n   * Truncate item text content\n   */\n  itemText?: boolean;\n  /**\n   * Truncate item description\n   */\n  itemDescription?: boolean;\n  /**\n   * Truncate section title\n   */\n  sectionTitle?: boolean;\n};\n\n// !Select types\n\nexport type SelectItemClassNames = {\n  /**\n   * The main slot for the listbox item. It wraps all the other slots.\n   */\n  base?: string;\n  /**\n   * `startContent`, `endContent` and `children` wrapper\n   */\n  contentWrapper?: string;\n  /**\n   * Left side of the content\n   */\n  startContent?: string;\n  /**\n   * Main content of the select item\n   */\n  mainContent?: string;\n  /**\n   * Main content of the select item\n   */\n  textContent?: string;\n  /**\n   * Main content of the select item\n   */\n  descriptionContent?: string;\n  /**\n   * Right side of the content\n   */\n  endContent?: string;\n  /**\n   * The selected icon slot. This is only visible when the item is selected - `âœ”`\n   */\n  selectedIcon?: string;\n};\n\nexport type SelectClassNames = {\n  /**\n   * The main wrapper of the select. This wraps the rest of the slots.\n   */\n  base?: string;\n  /**\n   * The label of the select.\n   */\n  label?: string;\n  /**\n   * The asterisk `*` after the label for `isRequired`.\n   */\n  requiredAsterisk?: string;\n  /**\n   * The trigger of the select. This wraps placeholder/value(s)/autocomplete-input and loading/caret.\n   */\n  trigger?: {\n    /**\n     * Trigger wrapper\n     */\n    base?: string;\n    /**\n     * The placeholder of the select.\n     */\n    placeholder?: string;\n    /**\n     * The default representation of selected value\n     */\n    valueText?: string;\n    valueChip?: string;\n    searchInput?: string;\n    /**\n     * The selector icon of the select. This is the icon that rotates when the select is open (data-open).\n     */\n    selectorIcon?: string;\n  };\n  /**\n   * The wrapper of the select content. This wraps the start/end content and the select value.\n   */\n  innerWrapper?: string;\n  /**\n   * The select value. This is also the slot that wraps the renderValue function result.\n   */\n  value?: string;\n  /**\n   * The wrapper of `topContent`, the listbox and `bottomContent`.\n   */\n  contentWrapper?: string;\n  /**\n   * The wrapper of the listbox. This wraps the listbox component, this slot is used on top of the scroll shadow component.\n   */\n  listboxWrapper?: string;\n  /**\n   * The listbox component. This is the component that wraps the select items.\n   */\n  listbox?: string;\n  /**\n   * The popover content slot. Use this to modify the popover content styles.\n   */\n  popover?: PopoverClassNames;\n  /**\n   * The wrapper of the helper text. This wraps the helper text and the error message.\n   */\n  helperWrapper?: string;\n  /**\n   * The description of the select.\n   */\n  description?: string;\n  /**\n   * The error message of the select.\n   */\n  errorMessage?: string;\n  /**\n   * Will apply classNames to all SelectItem-s\n   */\n  item?: SelectItemClassNames;\n  /**\n   * Will apply classNames to all SelectSection-s\n   */\n  section?: SelectSectionClassNames;\n};\n\nexport type SelectSectionClassNames = {\n  base?: string;\n  title?: string;\n};\n\nexport type RenderOption<T extends OptionItem> = ({\n  option,\n  currentOptions,\n}: {\n  option: T & { isSelected?: boolean; children?: React.ReactNode };\n  currentOptions?: (T & { isSelected?: boolean })[];\n}) => React.ReactNode;\n\nexport type SelectProps<T extends OptionItem> = {\n  onSelectionChange: OnSelectionChange<T>;\n  multiple?: boolean;\n  caret?: React.ReactNode;\n  showCaret?: boolean;\n  topContent?: React.ReactNode;\n  bottomContent?: React.ReactNode;\n  items?: T[];\n  placeholder?: string;\n  value?: T[];\n  defaultValue?: T[];\n  renderOption?: RenderOption<T>;\n  renderValue?: (selectedItems: T[]) => React.ReactNode;\n  children?:\n    | React.ReactNode\n    | ((item: T & { isSelected?: boolean }) => React.ReactNode);\n  label?: React.ReactNode;\n  isRequired?: boolean;\n  onClose?: (selectedItems?: T[]) => void;\n  openOnLabelClick?: boolean;\n  shouldCloseOnSelection?: boolean;\n  truncate?: SelectTruncate;\n  autoFocus?: ListAutoFocus;\n  search?: boolean | ((items: T[]) => T[]);\n  onSearchChange?: (searchQuery: string) => void;\n  description?: React.ReactNode;\n  errorMessage?: React.ReactNode;\n  noResultsMessage?: React.ReactNode;\n  infiniteScrollProps?: InfiniteScrollProps;\n  isLoading?: boolean;\n  /**\n   * Removes selected from the options list. Works only with `items` prop.\n   */\n  popOnSelection?: boolean;\n  /**\n   * Allows to set custom class names for the Select slots.\n   */\n  classNames?: SelectClassNames;\n} & Omit<\n  PopoverProps,\n  | 'content'\n  | 'delayShow'\n  | 'delayHide'\n  | 'hoverableContent'\n  | 'isNested'\n  | 'openOnHover'\n  | 'children'\n  | 'classNames'\n  | 'placement'\n  | 'onClose'\n>;\n\nexport type SelectItemProps<T extends OptionItem> = {\n  children: React.ReactNode;\n  shouldCloseOnSelection?: boolean;\n  showDisabledStyles?: boolean;\n  startContent?: React.ReactNode;\n  endContent?: React.ReactNode;\n  classNames?: SelectItemClassNames;\n  ref?: React.RefObject<HTMLLIElement | null>;\n} & T;\n\nexport type SelectTriggerProps = {\n  children: React.ReactNode;\n};\n\nexport type SelectSectionProps = {\n  children: React.ReactNode;\n  title?: React.ReactNode;\n  isStickyTitle?: boolean;\n  showDivider?: boolean;\n  classNames?: SelectSectionClassNames;\n};\n\nexport type SelectCompositionProps<T extends OptionItem> = {\n  /**\n   * SelectSection groups SelectItem components.\n   */\n  Section?: React.FC<SelectSectionProps>;\n  /**\n   * SelectItem is a clickable element that triggers the selection.\n   */\n  Item?: React.FC<SelectItemProps<T>>;\n  /**\n   * SelectDivider is a visual separator between sections.\n   */\n  Divider?: React.FC;\n};\n\nexport type OptionItem = {\n  value: string | number;\n  text: string;\n  textContent?: React.ReactNode;\n  description?: React.ReactNode;\n  disabled?: boolean;\n};\n\nexport type OnSelectionChange<T extends OptionItem> = (value: {\n  selectedOption?: T & { isSelected?: boolean };\n  selectedOptions: (T & { isSelected?: boolean })[];\n}) => void;\n\nexport type ListAutoFocus = 'first-item' | 'last-item' | 'menu' | 'none';\n\nexport type InfiniteScrollProps = {\n  onLoadMore: (search?: string) => void;\n  isLoading?: boolean;\n  hasMore: boolean;\n};\n"
    }
  ]
}