{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "select",
  "type": "registry:ui",
  "title": "Select",
  "description": "A customizable select component with search, sections, and keyboard navigation.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://raw.githubusercontent.com/Ninjaneer87/react-dropdown/main/packages/lab/registry/popover.json"
  ],
  "files": [
    {
      "path": "components/ui/select/Select.tsx",
      "type": "registry:ui",
      "target": "components/ui/select/Select.tsx",
      "content": "import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { OptionItem, SelectCompositionProps, SelectProps } from '../../types';\nimport SelectDivider from './SelectDivider';\nimport SelectItem from './SelectItem';\nimport SelectSection from './SelectSection';\nimport Popover from '../Popover/Popover';\nimport { SelectContext, SelectContextType } from '../../context/SelectContext';\nimport CaretIcon from '../ui/CaretIcon';\nimport { cn } from '../../utils/common';\nimport { useKeyboardNavigation } from '../../hooks/useKeyboardNavigation';\nimport { useInfiniteScroll } from '../../hooks/useInfiniteScroll';\nimport SpinnerLoader from '../SpinnerLoader/SpinnerLoader';\nimport styles from './Select.module.css';\nimport SelectSearch from '@/components/Select/SelectSearch';\n\nfunction Select<T extends OptionItem>({\n  // caret,\n  children,\n  trigger,\n  shouldFlip = true,\n  shouldBlockScroll = false,\n  shouldCloseOnScroll = false,\n  shouldCloseOnBlur = true,\n  shouldCloseOnEsc = true,\n  backdrop,\n  isDisabled,\n  isOpen: controlledIsOpen,\n  onOpen,\n  onClose,\n  onBlur,\n  onOpenChange,\n  fullWidth = false,\n  // showCaret,\n  growContent,\n  offset,\n  topContent,\n  bottomContent,\n  items,\n  onSelectionChange,\n  multiple = false,\n  renderOption,\n  placeholder = 'Select',\n  value,\n  defaultValue,\n  classNames,\n  label,\n  isRequired,\n  openOnLabelClick,\n  shouldCloseOnSelection,\n  truncate,\n  autoFocus = 'menu',\n  focusTrapProps = {\n    autoFocus: autoFocus === 'none',\n    trapFocus: true,\n  },\n  search,\n  onSearchChange,\n  description,\n  errorMessage,\n  renderValue,\n  noResultsMessage,\n  popOnSelection = true,\n  infiniteScrollProps,\n  isLoading,\n}: SelectProps<T> & SelectCompositionProps<T>) {\n  if (items && children && typeof children !== 'function') {\n    throw new Error(\n      'Invalid items configuration. Use only \"items\" prop (can be used with \"children\" as function) or only \"children\" as ReactNode, not both.',\n    );\n  }\n\n  if (!items && !children) {\n    throw new Error(\n      'Options are missing. Provide either \"items\" prop or \"children\".',\n    );\n  }\n\n  // Validate children\n  if (children && typeof children !== 'function') {\n    React.Children.forEach(children, (child) => {\n      if (!React.isValidElement(child)) return;\n\n      if (child.type !== SelectSection && child.type !== SelectItem) {\n        throw new Error(\n          `\"Select\" component only accepts \"SelectSection\" and \"SelectItem\" components as children`,\n        );\n      }\n    });\n  }\n\n  const { item: itemClassNames, section: sectionClassNames } = classNames || {};\n  const [isOpen, setIsOpen] = useState(false);\n  const [selected, setSelected] = useState<T[]>([]);\n  const [hasMountedDefaultValue, setHasMountedDefaultValue] = useState(false);\n  const [searchValue, setSearchValue] = useState('');\n  const baseRef = useRef<HTMLDivElement | null>(null);\n  const searchRef = useRef<HTMLInputElement | null>(null);\n\n  const open = controlledIsOpen ?? isOpen;\n  const loading = !!isLoading || !!infiniteScrollProps?.isLoading;\n\n  const focusSearch = useCallback(() => {\n    searchRef.current?.focus();\n  }, []);\n\n  const [loaderRef, scrollerRef] = useInfiniteScroll<never, HTMLUListElement>({\n    hasMore: infiniteScrollProps?.hasMore,\n    isEnabled: isOpen && !!infiniteScrollProps,\n    onLoadMore: () => infiniteScrollProps?.onLoadMore(searchValue),\n  });\n\n  const {\n    lastFocusedIndex,\n    containerRef,\n    onKeyDown,\n    focusItem,\n    mutationContainerRef,\n  } = useKeyboardNavigation<HTMLDivElement>({\n    autoFocus,\n    onFirstUp: search ? focusSearch : undefined,\n    onLastDown: search ? focusSearch : undefined,\n    isActive: open,\n  });\n\n  useEffect(() => {\n    if (!value) return;\n\n    setSelected(value);\n  }, [value]);\n\n  useEffect(() => {\n    if (!search || !open) return;\n\n    focusSearch();\n  }, [search, focusSearch, open]);\n\n  useEffect(() => {\n    if (!defaultValue || !defaultValue.length || hasMountedDefaultValue) return;\n\n    setSelected(defaultValue);\n    setHasMountedDefaultValue(true);\n  }, [defaultValue, hasMountedDefaultValue]);\n\n  function handleRemoveSelected(selectedValue: string | number) {\n    if (isDisabled) return;\n\n    const newSelected = selected.filter((item) => item.value !== selectedValue);\n    setSelected(newSelected);\n\n    if (onSelectionChange) {\n      onSelectionChange({\n        selectedOptions: newSelected,\n      });\n    }\n  }\n\n  const popoverContentClassName = cn('p-0');\n  const baseClassName = cn(\n    fullWidth ? 'w-full' : 'w-80',\n    isDisabled ? 'opacity-60 pointer-events-none' : '',\n  );\n  const labelClassName = cn('mb-1 w-fit', isDisabled ? 'opacity-60' : '');\n  const requiredAsteriskClassName = cn('text-red-700 ml-1');\n\n  const triggerBaseClassName = cn(\n    styles.triggerBase,\n    'rounded-lg border text-gray-800 border-gray-200 px-2 py-1 min-h-8 grow flex items-center gap-2 relative',\n  );\n  const triggerPlaceholderClassName = cn(\n    'text-[1em] leading-[1.2em] grow flex items-center text-gray-500',\n  );\n  const triggerValueTextClassName = 'flex items-center grow flex-wrap gap-1';\n  const triggerValueChipClassName = 'inline-flex items-center truncate';\n  const triggerSelectorIconClassName = cn('ml-auto inline-flex items-center');\n\n  const contentWrapperClassName =\n    'relative outline-none! border-none! p-2 grow';\n  const listboxClassName = cn(\n    'list-none pl-0 mb-0 max-h-[250px] overflow-y-auto relative  scroll-pt-12',\n  );\n  const helperWrapperClassName = cn('text-xs mt-1');\n  const descriptionClassName = cn('opacity-60');\n  const errorMessageClassName = cn('text-red-700');\n\n  const showPlaceholder = !selected.length && !search;\n\n  const showValue = !!selected.length || search;\n\n  const baseWidth = baseRef.current\n    ? window.getComputedStyle(baseRef.current).width\n    : 'initial';\n\n  const filteredItems = useMemo(() => {\n    if (!items) return items;\n\n    let newItems = [...items];\n\n    if (search) {\n      if (typeof search === 'function') {\n        newItems = search(items);\n      } else {\n        newItems = items.filter((item) =>\n          item.text.toLowerCase().includes(searchValue.toLowerCase()),\n        );\n      }\n    }\n\n    if (popOnSelection) {\n      newItems = newItems.filter((item) =>\n        selected.every((sel) => sel.value !== item.value),\n      );\n    }\n\n    return newItems;\n  }, [items, search, searchValue, popOnSelection, selected]);\n\n  const showNoFilteredResults =\n    filteredItems &&\n    !filteredItems.length &&\n    (!!searchValue.length ||\n      (popOnSelection && selected.length === items?.length));\n\n  if (showNoFilteredResults) {\n    filteredItems.push({\n      textContent: noResultsMessage,\n      text: 'No results',\n      value: 'no-results',\n      disabled: true,\n    } as T);\n  }\n\n  const showHelperSection = !!errorMessage || !!description;\n\n  const contextValue: SelectContextType<T> = useMemo(\n    () => ({\n      multiple,\n      onSelectionChange,\n      setSelected,\n      selected,\n      renderOption,\n      truncate,\n      itemClassNames,\n      sectionClassNames,\n      items,\n      searchValue,\n      setSearchValue,\n      focusItem,\n      search,\n      onSearchChange,\n      focusSearch: search ? focusSearch : undefined,\n      popOnSelection,\n      currentOptions: filteredItems,\n      lastFocusedIndex,\n    }),\n    [\n      multiple,\n      onSelectionChange,\n      setSelected,\n      selected,\n      renderOption,\n      truncate,\n      itemClassNames,\n      sectionClassNames,\n      items,\n      searchValue,\n      setSearchValue,\n      focusItem,\n      search,\n      onSearchChange,\n      focusSearch,\n      popOnSelection,\n      filteredItems,\n      lastFocusedIndex,\n    ],\n  );\n\n  return (\n    <SelectContext.Provider value={contextValue}>\n      {label && (\n        <div\n          className={cn(labelClassName, classNames?.label)}\n          onClick={() => {\n            if (!openOnLabelClick) return;\n\n            setIsOpen((prev) => !prev);\n          }}\n        >\n          {label}\n          {isRequired && (\n            <span\n              className={cn(\n                requiredAsteriskClassName,\n                classNames?.requiredAsterisk,\n              )}\n            >\n              *\n            </span>\n          )}\n        </div>\n      )}\n\n      <div className={cn(baseClassName, classNames?.base)} ref={baseRef}>\n        <Popover\n          fullWidth\n          shouldFlip={shouldFlip}\n          shouldBlockScroll={shouldBlockScroll}\n          shouldCloseOnScroll={shouldCloseOnScroll}\n          shouldCloseOnBlur={shouldCloseOnBlur}\n          shouldCloseOnEsc={shouldCloseOnEsc}\n          backdrop={backdrop}\n          focusTriggerOnClose\n          placement=\"bottom-center\"\n          isDisabled={isDisabled}\n          isOpen={open}\n          growContent={growContent}\n          offset={offset}\n          onOpen={() => {\n            setIsOpen(true);\n            if (onOpen) onOpen();\n          }}\n          onClose={() => {\n            setIsOpen(false);\n            if (onClose) onClose(selected);\n          }}\n          onBlur={() => {\n            if (onBlur) onBlur();\n          }}\n          onOpenChange={(isOpen) => {\n            setIsOpen(isOpen);\n            if (onOpenChange) onOpenChange(isOpen);\n          }}\n          classNames={{\n            ...classNames?.popover,\n            content: cn(popoverContentClassName, classNames?.popover?.content),\n          }}\n          focusTrapProps={focusTrapProps}\n        >\n          <Popover.Trigger>\n            {trigger ? (\n              trigger\n            ) : (\n              <div\n                className={cn(triggerBaseClassName, classNames?.trigger?.base)}\n              >\n                {showPlaceholder && (\n                  <div\n                    className={cn(\n                      triggerPlaceholderClassName,\n                      classNames?.trigger?.placeholder,\n                    )}\n                  >\n                    {placeholder ?? 'Select'}\n                  </div>\n                )}\n\n                {showValue && (\n                  <div\n                    className={cn(\n                      triggerValueTextClassName,\n                      classNames?.trigger?.valueText,\n                    )}\n                  >\n                    {renderValue ? (\n                      renderValue(selected)\n                    ) : (\n                      <>\n                        {selected.map((item) => (\n                          <button\n                            className={cn(\n                              triggerValueChipClassName,\n                              classNames?.trigger?.valueChip,\n                            )}\n                            key={item.value}\n                            onKeyDown={(e) => {\n                              if (e.key === 'Enter') {\n                                e.stopPropagation();\n                                e.preventDefault();\n\n                                handleRemoveSelected(item.value);\n                              }\n                            }}\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              e.preventDefault();\n\n                              handleRemoveSelected(item.value);\n                            }}\n                          >\n                            {item.textContent ?? item.text} &times;\n                          </button>\n                        ))}\n                      </>\n                    )}\n\n                    {search && (\n                      <SelectSearch\n                        searchRef={searchRef}\n                        placeholder={placeholder}\n                        className={classNames?.trigger?.searchInput}\n                      />\n                    )}\n                  </div>\n                )}\n\n                {loading ? (\n                  <SpinnerLoader />\n                ) : (\n                  <div\n                    className={cn(\n                      triggerSelectorIconClassName,\n                      classNames?.trigger?.selectorIcon,\n                    )}\n                  >\n                    <CaretIcon open={open} />\n                  </div>\n                )}\n              </div>\n            )}\n          </Popover.Trigger>\n\n          <Popover.Content>\n            <div style={{ width: baseWidth }}>\n              <div\n                className={cn(\n                  contentWrapperClassName,\n                  classNames?.contentWrapper,\n                )}\n                ref={(node) => {\n                  containerRef.current = node;\n                  mutationContainerRef.current = node;\n                }}\n                onKeyDown={onKeyDown}\n                tabIndex={0}\n              >\n                {topContent && topContent}\n                <ul\n                  ref={scrollerRef}\n                  className={cn(listboxClassName, classNames?.listbox)}\n                >\n                  {typeof children !== 'function' && children}\n                  {typeof children === 'function' &&\n                    filteredItems &&\n                    filteredItems.map((item) => {\n                      const renderedItem = children({\n                        ...item,\n                        isSelected: selected.some(\n                          (sel) => sel.value === item.value,\n                        ),\n                      });\n                      if (\n                        !React.isValidElement(renderedItem) ||\n                        renderedItem.type !== SelectItem\n                      ) {\n                        throw new Error(\n                          `\"Select\" children function only accepts \"SelectItem\" as a root returned element`,\n                        );\n                      }\n\n                      return renderedItem;\n                    })}\n\n                  {!children &&\n                    filteredItems &&\n                    filteredItems.map((item) => (\n                      <SelectItem\n                        key={item.value}\n                        {...item}\n                        shouldCloseOnSelection={shouldCloseOnSelection}\n                      >\n                        {item.textContent ?? item.text}\n                      </SelectItem>\n                    ))}\n\n                  {infiniteScrollProps?.hasMore && <li ref={loaderRef} />}\n                </ul>\n                {bottomContent && bottomContent}\n              </div>\n            </div>\n          </Popover.Content>\n        </Popover>\n\n        {showHelperSection && (\n          <div\n            className={cn(helperWrapperClassName, classNames?.helperWrapper)}\n          >\n            {description && (\n              <div\n                className={cn(descriptionClassName, classNames?.description)}\n              >\n                {description}\n              </div>\n            )}\n\n            {errorMessage && (\n              <div\n                className={cn(errorMessageClassName, classNames?.errorMessage)}\n              >\n                {errorMessage}\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </SelectContext.Provider>\n  );\n}\n\nSelect.Section = SelectSection;\nSelect.Item = SelectItem;\nSelect.Divider = SelectDivider;\n\nexport default Select;\n"
    },
    {
      "path": "components/ui/select/SelectItem.tsx",
      "type": "registry:ui",
      "target": "components/ui/select/SelectItem.tsx",
      "content": "import { useRef } from 'react';\nimport { usePopoverRootContext } from '../../context/PopoverRootContext';\nimport { useSelectContext } from '../../context/SelectContext';\nimport { OptionItem, SelectItemProps } from '../../types';\nimport { cn } from '../../utils/common';\nimport { Slot } from '../utility/Slot';\n\nfunction SelectItem<T extends OptionItem>({\n  children,\n  shouldCloseOnSelection = true,\n  disabled,\n  showDisabledStyles = true,\n  startContent,\n  endContent,\n  value,\n  text,\n  description,\n  classNames,\n  ref,\n  ...rest\n}: SelectItemProps<T>) {\n  const selectContext = useSelectContext<T>();\n  const popoverRootContext = usePopoverRootContext();\n\n  if (!selectContext) {\n    throw new Error('SelectItem should be used within a Select component');\n  }\n\n  if (!popoverRootContext) {\n    throw new Error('SelectItem should be used within a Popover component');\n  }\n\n  const {\n    onSelectionChange,\n    multiple,\n    selected,\n    setSelected,\n    renderOption,\n    truncate,\n    itemClassNames,\n    focusItem,\n    focusSearch,\n    lastFocusedIndex,\n    popOnSelection,\n    currentOptions,\n    search,\n  } = selectContext;\n\n  const { handleCloseRoot } = popoverRootContext;\n\n  const isOptionSelected = selected.some((item) => item.value === value);\n  const optionItem: T = {\n    value,\n    text,\n    description,\n    disabled,\n    children,\n    isSelected: isOptionSelected,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ...(rest as any),\n  };\n  const selectItemRef = useRef<HTMLLIElement | null>(null);\n\n  function handleSelection() {\n    if (disabled) return;\n\n    if (onSelectionChange) {\n      const selectedValues = selected.map((item) => item.value);\n      const isSelected = selectedValues.includes(value);\n      const isNewSelection = !isSelected;\n\n      let newSelectedOptions = [...selected];\n\n      if (isSelected) {\n        newSelectedOptions = newSelectedOptions.filter(\n          (item) => item.value !== value,\n        );\n      }\n\n      if (isNewSelection) {\n        if (multiple) {\n          newSelectedOptions = [...newSelectedOptions, optionItem];\n        } else {\n          newSelectedOptions = [optionItem];\n        }\n      }\n\n      onSelectionChange({\n        selectedOption: optionItem,\n        selectedOptions: newSelectedOptions,\n      });\n\n      setSelected(newSelectedOptions);\n    }\n\n    if (!search) {\n      focusItem({ index: lastFocusedIndex });\n    }\n\n    if (multiple && popOnSelection && search && focusSearch) {\n      focusSearch();\n    }\n\n    if (!multiple && shouldCloseOnSelection) {\n      handleCloseRoot();\n    }\n  }\n\n  function onKeyDown(event: React.KeyboardEvent<HTMLLIElement>) {\n    if (disabled) return;\n\n    if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      handleSelection();\n\n      return;\n    }\n  }\n\n  const baseClassName = cn(\n    disabled && showDisabledStyles ? 'opacity-60 pointer-events-none' : '',\n    'p-2 focus-visible:bg-gray-200 focus-within:bg-gray-200 rounded-lg transition-all w-full flex cursor-pointer items-center gap-2',\n  );\n  const contentWrapperClassName = cn(\n    'flex grow shrink-0 basis-36 justify-between items-center',\n  );\n  const startContentClassName = cn('shrink-0 inline-flex');\n  const mainContentClassName = cn('shrink-0 grow inline-block');\n  const textContentClassName = cn(\n    truncate?.itemText ? 'line-clamp-1 break-all grow' : '',\n  );\n  const descriptionContentClassName = cn(\n    'text-xs opacity-60',\n    truncate?.itemDescription ? 'line-clamp-1 break-all grow' : '',\n  );\n  const endContentClassName = cn('ml-auto shrink-0 inline-flex');\n  const selectedIconClassName = cn(\n    'transition-all origin-left',\n    isOptionSelected ? 'opacity-100 scale-x-100' : 'opacity-0 scale-x-0',\n  );\n\n  const itemProps = {\n    'data-focusable-item': true,\n    'data-select-menu-item': true,\n    'data-value': value,\n    'data-text': text,\n    tabIndex: disabled ? -1 : 0,\n    'data-disabled': disabled,\n    'aria-disabled': disabled,\n    onClick: handleSelection,\n    onKeyDown: onKeyDown,\n    ref: (node: HTMLLIElement | null) => {\n      selectItemRef.current = node;\n      if (ref) ref.current = node;\n    },\n    className: cn(baseClassName, itemClassNames?.base, classNames?.base),\n  };\n\n  if (renderOption) {\n    return (\n      <Slot {...itemProps}>\n        {renderOption({ option: optionItem, currentOptions })}\n      </Slot>\n    );\n  }\n\n  return (\n    <li {...itemProps}>\n      <span\n        className={cn(\n          contentWrapperClassName,\n          itemClassNames?.contentWrapper,\n          classNames?.contentWrapper,\n        )}\n      >\n        {startContent && (\n          <span\n            className={cn(\n              startContentClassName,\n              itemClassNames?.startContent,\n              classNames?.startContent,\n            )}\n          >\n            {startContent}\n          </span>\n        )}\n\n        <span\n          className={cn(\n            mainContentClassName,\n            itemClassNames?.mainContent,\n            classNames?.mainContent,\n          )}\n        >\n          <div\n            title={`${text}`}\n            className={cn(\n              textContentClassName,\n              itemClassNames?.textContent,\n              classNames?.textContent,\n            )}\n          >\n            {children}\n          </div>\n\n          {description && (\n            <div\n              className={cn(\n                descriptionContentClassName,\n                itemClassNames?.descriptionContent,\n                classNames?.descriptionContent,\n              )}\n            >\n              {description}\n            </div>\n          )}\n        </span>\n\n        {endContent && (\n          <span\n            className={cn(\n              endContentClassName,\n              itemClassNames?.endContent,\n              classNames?.endContent,\n            )}\n          >\n            {endContent}\n          </span>\n        )}\n      </span>\n\n      <span\n        className={cn(\n          selectedIconClassName,\n          itemClassNames?.selectedIcon,\n          classNames?.selectedIcon,\n        )}\n      >\n        &#10003;\n      </span>\n    </li>\n  );\n}\n\nexport default SelectItem;\n"
    },
    {
      "path": "components/ui/select/SelectSearch.tsx",
      "type": "registry:ui",
      "target": "components/ui/select/SelectSearch.tsx",
      "content": "import { useEffect } from 'react';\nimport { usePopoverContext } from '../../context/PopoverContext';\nimport { useSelectContext } from '../../context/SelectContext';\nimport { cn } from '../../utils/common';\n\ntype Props = {\n  placeholder: string;\n  searchRef: React.RefObject<HTMLInputElement | null>;\n  className?: string;\n};\n\nfunction SelectSearch({\n  placeholder = 'Search...',\n  searchRef,\n  className,\n}: Props) {\n  const popoverContext = usePopoverContext();\n  const selectContext = useSelectContext();\n\n  if (!popoverContext) {\n    throw new Error('SelectSearch should be used within a Popover component');\n  }\n  if (!selectContext) {\n    throw new Error('SelectSearch should be used within a Select component');\n  }\n\n  const { popoverId, isOpen, handleClose, handleOpen } = popoverContext;\n  const {\n    selected,\n    setSelected,\n    focusItem,\n    setSearchValue,\n    searchValue,\n    onSearchChange,\n  } = selectContext;\n\n  useEffect(() => {\n    if (!isOpen || !searchRef.current) return () => setSearchValue('');\n\n    searchRef.current.focus();\n\n    return () => setSearchValue('');\n  }, [isOpen, setSearchValue, searchRef]);\n\n  function onChange(e: React.ChangeEvent<HTMLInputElement>) {\n    e.preventDefault();\n    e.stopPropagation();\n    setSearchValue(e.target.value);\n    onSearchChange?.(e.target.value);\n  }\n\n  function onClick(e: React.MouseEvent<HTMLInputElement>) {\n    if (!isOpen) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  function onKeydown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    if (e.key === 'Tab') {\n      handleClose(false);\n    }\n\n    if (e.key === 'Backspace') {\n      if (!e.currentTarget.value && selected.length > 0) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        setSelected((prev) => prev.slice(0, -1));\n      }\n    }\n\n    if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      e.stopPropagation();\n      focusItem({ focusLast: true });\n    }\n\n    if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      e.stopPropagation();\n      focusItem({ index: 0 });\n    }\n  }\n\n  function onFocus() {\n    handleOpen();\n  }\n\n  const baseClassName =\n    'outline-none! bg-transparent border-none! grow max-w-full min-w-10 basis-10 text-[1em] leading-[1.2em] text-inherit p-0 font-[inherit] placeholder:text-gray-500';\n\n  return (\n    <input\n      onClick={onClick}\n      onKeyDown={onKeydown}\n      onChange={onChange}\n      onFocus={onFocus}\n      tabIndex={-1}\n      value={searchValue}\n      ref={searchRef}\n      className={cn(baseClassName, className)}\n      data-select-search={popoverId}\n      placeholder={selected.length > 0 ? '' : placeholder}\n    />\n  );\n}\n\nexport default SelectSearch;\n"
    },
    {
      "path": "components/ui/select/SelectSection.tsx",
      "type": "registry:ui",
      "target": "components/ui/select/SelectSection.tsx",
      "content": "import React from 'react';\nimport { useSelectContext } from '../../context/SelectContext';\nimport { SelectSectionProps } from '../../types';\nimport SelectItem from './SelectItem';\nimport SelectDivider from './SelectDivider';\nimport { cn } from '../../utils/common';\n\nfunction SelectSection({\n  children,\n  title,\n  isStickyTitle = true,\n  showDivider = true,\n  classNames,\n}: SelectSectionProps) {\n  const selectContext = useSelectContext();\n\n  if (!selectContext) {\n    throw new Error('SelectSection should be used within a Select component');\n  }\n\n  // Validate children\n  if (children) {\n    React.Children.forEach(children, (child) => {\n      if (!React.isValidElement(child)) return;\n\n      if (child.type !== SelectItem) {\n        throw new Error(\n          `\"SelectSection\" component only accepts \"SelectItem\" components as children`,\n        );\n      }\n    });\n  }\n  const { sectionClassNames } = selectContext;\n  const baseClassName = cn('bg-inherit');\n  const titleClassName = cn(\n    'bg-gray-100 p-1 text-sm font-semibold mb-2',\n    isStickyTitle ? 'sticky top-0 z-10 rounded-sm' : '',\n  );\n  const listClassName = 'pl-0 mb-0 list-none';\n\n  return (\n    <li\n      className={cn(baseClassName, sectionClassNames?.base, classNames?.base)}\n    >\n      {title && (\n        <div\n          className={cn(\n            titleClassName,\n            sectionClassNames?.title,\n            classNames?.title,\n          )}\n        >\n          {title}\n        </div>\n      )}\n\n      <ul className={listClassName}>{children}</ul>\n\n      {showDivider && <SelectDivider />}\n    </li>\n  );\n}\n\nexport default SelectSection;\n"
    },
    {
      "path": "components/ui/select/SelectDivider.tsx",
      "type": "registry:ui",
      "target": "components/ui/select/SelectDivider.tsx",
      "content": "import { cn } from '../../utils/common';\nimport { dividerBaseClassName } from '../../utils/elements';\n\nfunction SelectDivider() {\n  return <div className={cn(dividerBaseClassName)} />;\n}\n\nexport default SelectDivider;\n"
    },
    {
      "path": "components/ui/select/Select.module.css",
      "type": "registry:ui",
      "target": "components/ui/select/Select.module.css",
      "content": "/* .triggerBase {\n    background-color: white;\n} */"
    },
    {
      "path": "components/ui/select/index.ts",
      "type": "registry:ui",
      "target": "components/ui/select/index.ts",
      "content": "export { default as Select } from './Select';\nexport { default as SelectDivider } from './SelectDivider';\nexport { default as SelectItem } from './SelectItem';\nexport { default as SelectSection } from './SelectSection';\n"
    },
    {
      "path": "components/ui/select/context/SelectContext.ts",
      "type": "registry:ui",
      "target": "components/ui/select/context/SelectContext.ts",
      "content": "import { createContext, Dispatch, SetStateAction, useContext } from 'react';\nimport {\n  OnSelectionChange,\n  OptionItem,\n  RenderOption,\n  SelectItemClassNames,\n  SelectSectionClassNames,\n  SelectTruncate,\n} from '../types';\nimport { FocusItemProps } from '@/hooks/useKeyboardNavigation';\n\nexport type SelectContextType<T extends OptionItem = OptionItem> = {\n  multiple: boolean;\n  onSelectionChange: OnSelectionChange<T>;\n  setSelected: Dispatch<SetStateAction<T[]>>;\n  selected: T[];\n  renderOption?: RenderOption<T>;\n  truncate?: SelectTruncate;\n  itemClassNames?: SelectItemClassNames;\n  sectionClassNames?: SelectSectionClassNames;\n  items?: T[];\n  setSearchValue: React.Dispatch<React.SetStateAction<string>>;\n  searchValue: string;\n  focusItem: (props: FocusItemProps) => void;\n  lastFocusedIndex?: number;\n  search?: boolean | ((items: T[]) => T[]);\n  onSearchChange?: (searchQuery: string) => void;\n  focusSearch?: () => void;\n  popOnSelection?: boolean;\n  currentOptions?: T[];\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const SelectContext = createContext<SelectContextType<any> | null>(null);\n\nexport const useSelectContext = <T extends OptionItem>() =>\n  useContext(SelectContext) as SelectContextType<T> | null;\n"
    },
    {
      "path": "components/ui/select/context/SelectMenuContext.ts",
      "type": "registry:ui",
      "target": "components/ui/select/context/SelectMenuContext.ts",
      "content": "import { createContext, useContext } from 'react';\n\ntype SelectMenuContextType = {\n  setFocusedIndex: React.Dispatch<React.SetStateAction<number | undefined>>;\n};\n\nexport const SelectMenuContext = createContext<SelectMenuContextType | null>(\n  null,\n);\n\nexport const useSelectMenuContext = () => useContext(SelectMenuContext);\n"
    },
    {
      "path": "components/ui/select/types.ts",
      "type": "registry:ui",
      "target": "components/ui/select/types.ts",
      "content": "import { ComponentPropsWithRef, ElementType } from 'react';\n\n// !Popover types\nexport type PopoverPosition = 'top' | 'bottom' | 'left' | 'right';\nexport type PopoverAlign = 'start' | 'end' | 'center';\nexport type PopoverPlacement = `${PopoverPosition}-${PopoverAlign}`;\n\nexport type Backdrop = 'transparent' | 'opaque' | 'blur';\n\ntype PopoverClassNames = {\n  base?: string;\n  trigger?: string;\n  backdrop?: string;\n  content?: string;\n};\n\nexport type PopoverProps = {\n  children?: React.ReactNode;\n  trigger?: React.ReactNode;\n  content?: React.ReactNode;\n  shouldFlip?: boolean;\n  shouldBlockScroll?: boolean;\n  shouldCloseOnBlur?: boolean;\n  shouldCloseOnEsc?: boolean;\n  shouldCloseOnScroll?: boolean;\n  backdrop?: Backdrop;\n  placement?: PopoverPlacement;\n  offset?: number;\n  isDisabled?: boolean;\n  isOpen?: boolean;\n  showArrow?: boolean;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onBlur?: () => void;\n  onOpenChange?: (isOpen: boolean) => void;\n  isNested?: boolean;\n  fullWidth?: boolean;\n  openOnHover?: boolean;\n  focusTriggerOnClose?: boolean;\n  delayShow?: number;\n  delayHide?: number;\n  hoverableContent?: boolean;\n  growContent?: boolean;\n  classNames?: PopoverClassNames;\n  focusTrapProps?: {\n    trapFocus?: boolean;\n    autoFocus?: boolean;\n  };\n};\n\nexport type PopoverTriggerProps = {\n  children: React.ReactNode;\n};\n\nexport type PopoverContentProps = {\n  children: React.ReactNode;\n};\n\nexport type PopoverComposition = {\n  /**\n   *  The component that triggers the popover\n   */\n  Trigger?: React.FC<PopoverTriggerProps>;\n\n  /**\n   * The component that contains the popover content.\n   */\n  Content?: React.FC<PopoverContentProps>;\n};\n\nexport type DropdownClassNames = {\n  popover?: PopoverClassNames;\n  divider?: DropdownDividerClassNames;\n  footer?: DropdownFooterClassNames;\n  header?: DropdownHeaderClassNames;\n  menu?: DropdownMenuClassNames;\n  item?: DropdownItemClassNames;\n  section?: DropdownSectionClassNames;\n};\n\ntype DropdownItemClassNames = {\n  base?: string;\n  startContent?: string;\n  mainContent?: string;\n  textContent?: string;\n  descriptionContent?: string;\n  endContent?: string;\n};\n\ntype DropdownSectionClassNames = {\n  base?: string;\n  title?: string;\n};\ntype DropdownTriggerClassNames = {\n  base?: string;\n};\ntype DropdownDividerClassNames = {\n  base?: string;\n};\ntype DropdownMenuClassNames = {\n  base?: string;\n};\ntype DropdownHeaderClassNames = {\n  base?: string;\n};\ntype DropdownFooterClassNames = {\n  base?: string;\n};\n// !Dropdown types\nexport type DropdownProps = {\n  shouldCloseOnSelection?: boolean;\n  caret?: React.ReactNode;\n  showCaret?: boolean;\n  classNames?: DropdownClassNames;\n  autoFocus?: ListAutoFocus;\n} & Omit<\n  PopoverProps,\n  'content' | 'delayShow' | 'delayHide' | 'hoverableContent' | 'classNames'\n>;\n\nexport type DropdownMenuProps = {\n  children: React.ReactNode;\n  isOpen?: boolean;\n  classNames?: DropdownMenuClassNames;\n};\n\nexport type DropdownHeaderProps = {\n  children: React.ReactNode;\n  isSticky?: boolean;\n  classNames?: DropdownHeaderClassNames;\n};\n\nexport type DropdownFooterProps = {\n  children: React.ReactNode;\n  isSticky?: boolean;\n  classNames?: DropdownFooterClassNames;\n};\n\nexport type DropdownSectionProps = {\n  children: React.ReactNode;\n  scrolling?: boolean;\n  title?: React.ReactNode;\n  isStickyTitle?: boolean;\n  infiniteScrollProps?: InfiniteScrollProps;\n  classNames?: DropdownSectionClassNames;\n};\n\nexport type DropdownItemProps<T extends ElementType = 'div'> = {\n  children: React.ReactNode;\n  isHighlighted?: boolean;\n  shouldCloseOnSelection?: boolean;\n  disabled?: boolean;\n  showDisabledStyles?: boolean;\n  startContent?: React.ReactNode;\n  endContent?: React.ReactNode;\n  as?: T;\n  classNames?: DropdownItemClassNames;\n  /**\n   * The description of the select.\n   */\n  description?: string;\n} & Omit<ComponentPropsWithRef<T>, 'children' | 'className'>;\n\nexport type DropdownTriggerProps = {\n  children: React.ReactNode;\n  classNames?: DropdownTriggerClassNames;\n};\n\nexport type DropdownDividerProps = {\n  classNames?: DropdownDividerClassNames;\n};\n\nexport type DropdownComposition = {\n  /**\n   * DropdownMenu is a container for DropdownSection and DropdownItem components.\n   */\n  Menu?: React.FC<DropdownMenuProps>;\n  /**\n   * DropdownHeader is a non-clickable element that provides context for the Dropdown.\n   */\n  Header?: React.FC<DropdownHeaderProps>;\n  /**\n   * DropdownFooter provides bottom space, usually used for actions.\n   */\n  Footer?: React.FC<DropdownFooterProps>;\n  /**\n   * DropdownSection groups DropdownItem components.\n   */\n  Section?: React.FC<DropdownSectionProps>;\n  /**\n   * DropdownItem is a clickable element that triggers an action.\n   */\n  Item?: React.FC<DropdownItemProps>;\n  /**\n   * DropdownTrigger is a clickable element that toggles the dropdown.\n   */\n  Trigger?: React.FC<DropdownTriggerProps>;\n\n  /**\n   * DropdownDivider is a visual separator between sections.\n   */\n  Divider?: React.FC<DropdownDividerProps>;\n};\n\nexport type SelectTruncate = {\n  /**\n   * Show selected value(s) in one line only\n   */\n  value?: boolean;\n  /**\n   * Truncate item text content\n   */\n  itemText?: boolean;\n  /**\n   * Truncate item description\n   */\n  itemDescription?: boolean;\n  /**\n   * Truncate section title\n   */\n  sectionTitle?: boolean;\n};\n\n// !Select types\n\nexport type SelectItemClassNames = {\n  /**\n   * The main slot for the listbox item. It wraps all the other slots.\n   */\n  base?: string;\n  /**\n   * `startContent`, `endContent` and `children` wrapper\n   */\n  contentWrapper?: string;\n  /**\n   * Left side of the content\n   */\n  startContent?: string;\n  /**\n   * Main content of the select item\n   */\n  mainContent?: string;\n  /**\n   * Main content of the select item\n   */\n  textContent?: string;\n  /**\n   * Main content of the select item\n   */\n  descriptionContent?: string;\n  /**\n   * Right side of the content\n   */\n  endContent?: string;\n  /**\n   * The selected icon slot. This is only visible when the item is selected - `âœ”`\n   */\n  selectedIcon?: string;\n};\n\nexport type SelectClassNames = {\n  /**\n   * The main wrapper of the select. This wraps the rest of the slots.\n   */\n  base?: string;\n  /**\n   * The label of the select.\n   */\n  label?: string;\n  /**\n   * The asterisk `*` after the label for `isRequired`.\n   */\n  requiredAsterisk?: string;\n  /**\n   * The trigger of the select. This wraps placeholder/value(s)/autocomplete-input and loading/caret.\n   */\n  trigger?: {\n    /**\n     * Trigger wrapper\n     */\n    base?: string;\n    /**\n     * The placeholder of the select.\n     */\n    placeholder?: string;\n    /**\n     * The default representation of selected value\n     */\n    valueText?: string;\n    valueChip?: string;\n    searchInput?: string;\n    /**\n     * The selector icon of the select. This is the icon that rotates when the select is open (data-open).\n     */\n    selectorIcon?: string;\n  };\n  /**\n   * The wrapper of the select content. This wraps the start/end content and the select value.\n   */\n  innerWrapper?: string;\n  /**\n   * The select value. This is also the slot that wraps the renderValue function result.\n   */\n  value?: string;\n  /**\n   * The wrapper of `topContent`, the listbox and `bottomContent`.\n   */\n  contentWrapper?: string;\n  /**\n   * The wrapper of the listbox. This wraps the listbox component, this slot is used on top of the scroll shadow component.\n   */\n  listboxWrapper?: string;\n  /**\n   * The listbox component. This is the component that wraps the select items.\n   */\n  listbox?: string;\n  /**\n   * The popover content slot. Use this to modify the popover content styles.\n   */\n  popover?: PopoverClassNames;\n  /**\n   * The wrapper of the helper text. This wraps the helper text and the error message.\n   */\n  helperWrapper?: string;\n  /**\n   * The description of the select.\n   */\n  description?: string;\n  /**\n   * The error message of the select.\n   */\n  errorMessage?: string;\n  /**\n   * Will apply classNames to all SelectItem-s\n   */\n  item?: SelectItemClassNames;\n  /**\n   * Will apply classNames to all SelectSection-s\n   */\n  section?: SelectSectionClassNames;\n};\n\nexport type SelectSectionClassNames = {\n  base?: string;\n  title?: string;\n};\n\nexport type RenderOption<T extends OptionItem> = ({\n  option,\n  currentOptions,\n}: {\n  option: T & { isSelected?: boolean; children?: React.ReactNode };\n  currentOptions?: (T & { isSelected?: boolean })[];\n}) => React.ReactNode;\n\nexport type SelectProps<T extends OptionItem> = {\n  onSelectionChange: OnSelectionChange<T>;\n  multiple?: boolean;\n  caret?: React.ReactNode;\n  showCaret?: boolean;\n  topContent?: React.ReactNode;\n  bottomContent?: React.ReactNode;\n  items?: T[];\n  placeholder?: string;\n  value?: T[];\n  defaultValue?: T[];\n  renderOption?: RenderOption<T>;\n  renderValue?: (selectedItems: T[]) => React.ReactNode;\n  children?:\n    | React.ReactNode\n    | ((item: T & { isSelected?: boolean }) => React.ReactNode);\n  label?: React.ReactNode;\n  isRequired?: boolean;\n  onClose?: (selectedItems?: T[]) => void;\n  openOnLabelClick?: boolean;\n  shouldCloseOnSelection?: boolean;\n  truncate?: SelectTruncate;\n  autoFocus?: ListAutoFocus;\n  search?: boolean | ((items: T[]) => T[]);\n  onSearchChange?: (searchQuery: string) => void;\n  description?: React.ReactNode;\n  errorMessage?: React.ReactNode;\n  noResultsMessage?: React.ReactNode;\n  infiniteScrollProps?: InfiniteScrollProps;\n  isLoading?: boolean;\n  /**\n   * Removes selected from the options list. Works only with `items` prop.\n   */\n  popOnSelection?: boolean;\n  /**\n   * Allows to set custom class names for the Select slots.\n   */\n  classNames?: SelectClassNames;\n} & Omit<\n  PopoverProps,\n  | 'content'\n  | 'delayShow'\n  | 'delayHide'\n  | 'hoverableContent'\n  | 'isNested'\n  | 'openOnHover'\n  | 'children'\n  | 'classNames'\n  | 'placement'\n  | 'onClose'\n>;\n\nexport type SelectItemProps<T extends OptionItem> = {\n  children: React.ReactNode;\n  shouldCloseOnSelection?: boolean;\n  showDisabledStyles?: boolean;\n  startContent?: React.ReactNode;\n  endContent?: React.ReactNode;\n  classNames?: SelectItemClassNames;\n  ref?: React.RefObject<HTMLLIElement | null>;\n} & T;\n\nexport type SelectTriggerProps = {\n  children: React.ReactNode;\n};\n\nexport type SelectSectionProps = {\n  children: React.ReactNode;\n  title?: React.ReactNode;\n  isStickyTitle?: boolean;\n  showDivider?: boolean;\n  classNames?: SelectSectionClassNames;\n};\n\nexport type SelectCompositionProps<T extends OptionItem> = {\n  /**\n   * SelectSection groups SelectItem components.\n   */\n  Section?: React.FC<SelectSectionProps>;\n  /**\n   * SelectItem is a clickable element that triggers the selection.\n   */\n  Item?: React.FC<SelectItemProps<T>>;\n  /**\n   * SelectDivider is a visual separator between sections.\n   */\n  Divider?: React.FC;\n};\n\nexport type OptionItem = {\n  value: string | number;\n  text: string;\n  textContent?: React.ReactNode;\n  description?: React.ReactNode;\n  disabled?: boolean;\n};\n\nexport type OnSelectionChange<T extends OptionItem> = (value: {\n  selectedOption?: T & { isSelected?: boolean };\n  selectedOptions: (T & { isSelected?: boolean })[];\n}) => void;\n\nexport type ListAutoFocus = 'first-item' | 'last-item' | 'menu' | 'none';\n\nexport type InfiniteScrollProps = {\n  onLoadMore: (search?: string) => void;\n  isLoading?: boolean;\n  hasMore: boolean;\n};\n"
    }
  ]
}